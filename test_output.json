{
  "metadata": {
    "source_file": "page_6.pdf",
    "total_pages": 9,
    "processing_time_seconds": 1362.0,
    "processed_at": "2026-01-06T11:52:10.361294",
    "model": "ByteDance/Dolphin-v2"
  },
  "pages": [
    {
      "page_number": 1,
      "elements": [
        {
          "type": "figure",
          "content": "[Figure]",
          "bbox": [
            74,
            15,
            123,
            49
          ]
        },
        {
          "type": "paragraph",
          "content": "This CVPR paper is the Open Access version, provided by the Computer Vision Foundation.\nExcept for this watermark, it is identical to the version available on IEEE Xplore.",
          "bbox": [
            147,
            18,
            543,
            46
          ]
        },
        {
          "type": "heading",
          "content": "Deep Residual Learning for Image Recognition",
          "bbox": [
            170,
            116,
            501,
            138
          ]
        },
        {
          "type": "paragraph",
          "content": "Kaiming He\nXiangyu Zhang\nShaoqing Ren\nJian Sun\n\nMicrosoft Research\n\n{kahe, v-xiang, v-shren, jiansun}@microsoft.com",
          "bbox": [
            151,
            168,
            520,
            224
          ]
        },
        {
          "type": "heading",
          "content": "Abstract",
          "bbox": [
            164,
            251,
            216,
            268
          ]
        },
        {
          "type": "paragraph",
          "content": "Deeper neural networks are more difficult to train. We\npresent a residual learning framework to ease the training\nof networks that are substantially deeper than those used\npreviously. We explicitly reformulate the layers as learn-\ning residual functions with reference to the layer inputs, in-\nstead of learning unrefereed functions. We provide com-\nprehensive empirical evidence showing that these residual\nnetworks are easier to optimize, and can gain accuracy from\ninput changes. The proposed method can also be used to\nevaluate residual nets with a depth of up to 152 layers—8 x\ndeeper than VGG nets [40] but still having lower complex-\nity. An ensemble of these residual nets achieves 3.57 % error\non the ImageNet test set. This result won the 1st place on the\nILSVRC 2015 classification task. We also present analysis\non CIFAR-10 with 100 and 1000 layers.",
          "bbox": [
            53,
            276,
            326,
            480
          ]
        },
        {
          "type": "paragraph",
          "content": "The depth of representations is of central importance\nfor many visual recognition tasks. Solely due to our ex-\ntremely deep representations, we obtain a 28 % relative im-\nprovement on the COCO object detection dataset. Deep\nresidual nets are foundations of our submissions to ILSVRC\n& COCO 2015 competitions 1 , where we also won the 1st\nplaces on the tasks of ImageNet detection, ImageNet local-\nization, COCO detection, and COCO segmentation.",
          "bbox": [
            54,
            480,
            326,
            590
          ]
        },
        {
          "type": "heading",
          "content": "1. Introduction",
          "bbox": [
            55,
            602,
            145,
            620
          ]
        },
        {
          "type": "paragraph",
          "content": "Deep convolutional neural networks [22, 21] have led\nto a series of breakthroughs for image classification [21,\n49, 39] . Deep networks naturally integrate low/mid/high-\nlevel features [49] and classifiers in an end-to-end multi-\nlayer fashion, and the “ levels ” of features can be enriched\nby the number of stacked layers (depth). Recent evidence\nhas found that convolutional neural networks perform well\nand the leading results [40, 43, 12, 16] on the challenging\nImageNet dataset [35] all exploit “ very deep ” [40] models,\nwith a depth of sixteen [40] to thirty [16] . Many other non-\ntrivial visual recognition tasks [7, 11, 6, 32, 27] have also",
          "bbox": [
            54,
            627,
            326,
            777
          ]
        },
        {
          "type": "paragraph",
          "content": "greatly benefited from very deep models.",
          "bbox": [
            347,
            408,
            534,
            423
          ]
        },
        {
          "type": "figure",
          "content": "[Figure]",
          "bbox": [
            347,
            251,
            619,
            340
          ]
        },
        {
          "type": "paragraph",
          "content": "Figure. 1. Training error (left) and test error (right) on CIFAR-10\nwith 20-layer and 56-layer \"plain\" networks. The deeper network\nhas higher training error, and thus test error. Similar phenomena\non ImageNet is presented in Fig. 4 .",
          "bbox": [
            346,
            343,
            619,
            394
          ]
        },
        {
          "type": "paragraph",
          "content": "Driven by the significance of depth, a question arises: Is\nLearning better networks as easy as stacking more layers?\nAn obstacle to answering this question was the notorious\nproblem of vanishing/exploding gradients [14, 1, 8] , which\nhamper convergence from the beginning. This problem,\nhowever, has been largely addressed by normalized initial-\nization [23, 8, 36, 12] and intermediate normalization layers\n[16] , which enable networks with tens of layers to start con-\nverging for stochastic gradient descent (SGD) with back-\npropagation [22] .",
          "bbox": [
            346,
            423,
            619,
            560
          ]
        },
        {
          "type": "paragraph",
          "content": "When deeper networks are able to start converging, a\ndegradation problem has been exposed: with the network\ndepth increasing, accuracy gets saturated (which might be\nunsurprising) and then degrades rapidly. Unexpectedly,\nsuch degradation is not caused by overfitting , and adding\nmore layers to a suitably deep model leads to higher train-\ning error , as reported in [10, 41] and thoroughly verified by\nour experiments. Fig. 1 shows a typical example.",
          "bbox": [
            346,
            561,
            619,
            671
          ]
        },
        {
          "type": "paragraph",
          "content": "The degradation of (training accuracy) indicates that not\nall systems are similarly easy to optimize. Let us consider a\nshallower architecture and its deeper counterpart that adds\nmore layers onto it. There exists a solution by construction\nto the deeper model: the added layers are identity mapping,\nand the other layers are copied from the learned shallower\nmodel. The existence of this constructed solution indicates\nthat a deeper model should produce no higher training error\nthan its shallower counterpart. But experiments show that\nour current solvers on hand are unable to find solutions that",
          "bbox": [
            346,
            672,
            619,
            808
          ]
        },
        {
          "type": "footnote",
          "content": "' http://image-net.org/challenges/LSVRC/2015, and\n' http://mccoco.org/dataset/detections-challenge2015 .",
          "bbox": [
            55,
            785,
            325,
            808
          ]
        },
        {
          "type": "paragraph",
          "content": "770",
          "bbox": [
            337,
            829,
            355,
            842
          ]
        }
      ],
      "text": "[Figure]\n\nThis CVPR paper is the Open Access version, provided by the Computer Vision Foundation.\nExcept for this watermark, it is identical to the version available on IEEE Xplore.\n\nDeep Residual Learning for Image Recognition\n\nKaiming He\nXiangyu Zhang\nShaoqing Ren\nJian Sun\n\nMicrosoft Research\n\n{kahe, v-xiang, v-shren, jiansun}@microsoft.com\n\nAbstract\n\nDeeper neural networks are more difficult to train. We\npresent a residual learning framework to ease the training\nof networks that are substantially deeper than those used\npreviously. We explicitly reformulate the layers as learn-\ning residual functions with reference to the layer inputs, in-\nstead of learning unrefereed functions. We provide com-\nprehensive empirical evidence showing that these residual\nnetworks are easier to optimize, and can gain accuracy from\ninput changes. The proposed method can also be used to\nevaluate residual nets with a depth of up to 152 layers—8 x\ndeeper than VGG nets [40] but still having lower complex-\nity. An ensemble of these residual nets achieves 3.57 % error\non the ImageNet test set. This result won the 1st place on the\nILSVRC 2015 classification task. We also present analysis\non CIFAR-10 with 100 and 1000 layers.\n\nThe depth of representations is of central importance\nfor many visual recognition tasks. Solely due to our ex-\ntremely deep representations, we obtain a 28 % relative im-\nprovement on the COCO object detection dataset. Deep\nresidual nets are foundations of our submissions to ILSVRC\n& COCO 2015 competitions 1 , where we also won the 1st\nplaces on the tasks of ImageNet detection, ImageNet local-\nization, COCO detection, and COCO segmentation.\n\n1. Introduction\n\nDeep convolutional neural networks [22, 21] have led\nto a series of breakthroughs for image classification [21,\n49, 39] . Deep networks naturally integrate low/mid/high-\nlevel features [49] and classifiers in an end-to-end multi-\nlayer fashion, and the “ levels ” of features can be enriched\nby the number of stacked layers (depth). Recent evidence\nhas found that convolutional neural networks perform well\nand the leading results [40, 43, 12, 16] on the challenging\nImageNet dataset [35] all exploit “ very deep ” [40] models,\nwith a depth of sixteen [40] to thirty [16] . Many other non-\ntrivial visual recognition tasks [7, 11, 6, 32, 27] have also\n\ngreatly benefited from very deep models.\n\n[Figure]\n\nFigure. 1. Training error (left) and test error (right) on CIFAR-10\nwith 20-layer and 56-layer \"plain\" networks. The deeper network\nhas higher training error, and thus test error. Similar phenomena\non ImageNet is presented in Fig. 4 .\n\nDriven by the significance of depth, a question arises: Is\nLearning better networks as easy as stacking more layers?\nAn obstacle to answering this question was the notorious\nproblem of vanishing/exploding gradients [14, 1, 8] , which\nhamper convergence from the beginning. This problem,\nhowever, has been largely addressed by normalized initial-\nization [23, 8, 36, 12] and intermediate normalization layers\n[16] , which enable networks with tens of layers to start con-\nverging for stochastic gradient descent (SGD) with back-\npropagation [22] .\n\nWhen deeper networks are able to start converging, a\ndegradation problem has been exposed: with the network\ndepth increasing, accuracy gets saturated (which might be\nunsurprising) and then degrades rapidly. Unexpectedly,\nsuch degradation is not caused by overfitting , and adding\nmore layers to a suitably deep model leads to higher train-\ning error , as reported in [10, 41] and thoroughly verified by\nour experiments. Fig. 1 shows a typical example.\n\nThe degradation of (training accuracy) indicates that not\nall systems are similarly easy to optimize. Let us consider a\nshallower architecture and its deeper counterpart that adds\nmore layers onto it. There exists a solution by construction\nto the deeper model: the added layers are identity mapping,\nand the other layers are copied from the learned shallower\nmodel. The existence of this constructed solution indicates\nthat a deeper model should produce no higher training error\nthan its shallower counterpart. But experiments show that\nour current solvers on hand are unable to find solutions that\n\n' http://image-net.org/challenges/LSVRC/2015, and\n' http://mccoco.org/dataset/detections-challenge2015 .\n\n770",
      "markdown": "![Figure 0](data:image/png;base64,[Figure])\n\nThis CVPR paper is the Open Access version, provided by the Computer Vision Foundation. Except for this watermark, it is identical to the version available on IEEE Xplore.\n\n# Deep Residual Learning for Image Recognition\n\nKaiming He Xiangyu Zhang Shaoqing Ren Jian Sun\n\nMicrosoft Research\n\n{kahe, v-xiang, v-shren, jiansun}@microsoft.com\n\n## Abstract\n\nDeeper neural networks are more difficult to train. We present a residual learning framework to ease the training of networks that are substantially deeper than those used previously. We explicitly reformulate the layers as learning residual functions with reference to the layer inputs, instead of learning unrefereed functions. We provide comprehensive empirical evidence showing that these residual networks are easier to optimize, and can gain accuracy from input changes. The proposed method can also be used to evaluate residual nets with a depth of up to 152 layers—8 x deeper than VGG nets [40] but still having lower complexity. An ensemble of these residual nets achieves 3.57 % error on the ImageNet test set. This result won the 1st place on the ILSVRC 2015 classification task. We also present analysis on CIFAR-10 with 100 and 1000 layers.\n\nThe depth of representations is of central importance for many visual recognition tasks. Solely due to our extremely deep representations, we obtain a 28 % relative improvement on the COCO object detection dataset. Deep residual nets are foundations of our submissions to ILSVRC & COCO 2015 competitions 1 , where we also won the 1st places on the tasks of ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation.\n\n## 1. Introduction\n\nDeep convolutional neural networks [22, 21] have led to a series of breakthroughs for image classification [21, 49, 39] . Deep networks naturally integrate low/mid/highlevel features [49] and classifiers in an end-to-end multilayer fashion, and the “ levels ” of features can be enriched by the number of stacked layers (depth). Recent evidence has found that convolutional neural networks perform well and the leading results [40, 43, 12, 16] on the challenging ImageNet dataset [35] all exploit “ very deep ” [40] models, with a depth of sixteen [40] to thirty [16] . Many other nontrivial visual recognition tasks [7, 11, 6, 32, 27] have also\n\ngreatly benefited from very deep models.\n\n![Figure 10](data:image/png;base64,[Figure])\n\nFigure. 1. Training error (left) and test error (right) on CIFAR-10 with 20-layer and 56-layer \"plain\" networks. The deeper network has higher training error, and thus test error. Similar phenomena on ImageNet is presented in Fig. 4 .\n\nDriven by the significance of depth, a question arises: Is Learning better networks as easy as stacking more layers? An obstacle to answering this question was the notorious problem of vanishing/exploding gradients [14, 1, 8] , which hamper convergence from the beginning. This problem, however, has been largely addressed by normalized initialization [23, 8, 36, 12] and intermediate normalization layers [16] , which enable networks with tens of layers to start converging for stochastic gradient descent (SGD) with backpropagation [22] .\n\nWhen deeper networks are able to start converging, a degradation problem has been exposed: with the network depth increasing, accuracy gets saturated (which might be unsurprising) and then degrades rapidly. Unexpectedly, such degradation is not caused by overfitting , and adding more layers to a suitably deep model leads to higher training error , as reported in [10, 41] and thoroughly verified by our experiments. Fig. 1 shows a typical example.\n\nThe degradation of (training accuracy) indicates that not all systems are similarly easy to optimize. Let us consider a shallower architecture and its deeper counterpart that adds more layers onto it. There exists a solution by construction to the deeper model: the added layers are identity mapping, and the other layers are copied from the learned shallower model. The existence of this constructed solution indicates that a deeper model should produce no higher training error than its shallower counterpart. But experiments show that our current solvers on hand are unable to find solutions that\n\n' http://image-net.org/challenges/LSVRC/2015, and ' http://mccoco.org/dataset/detections-challenge2015 .\n\n770\n\n"
    },
    {
      "page_number": 2,
      "elements": [
        {
          "type": "figure",
          "content": "[Figure]",
          "bbox": [
            111,
            86,
            264,
            175
          ]
        },
        {
          "type": "paragraph",
          "content": "Figure 2. Residual learning: a building block.",
          "bbox": [
            96,
            177,
            283,
            190
          ]
        },
        {
          "type": "paragraph",
          "content": "are comparably good or better than the constructed solution\n(or unable to do so in feasible time).",
          "bbox": [
            53,
            204,
            325,
            232
          ]
        },
        {
          "type": "paragraph",
          "content": "In this paper, we address the degradation problem by\nintroducing a deep residual learning framework. In-\nstead of hoping each few stacked layers directly fit a\ndesired underlying mapping, we explicitly let these lay-\ners fit a residual mapping. Formally, denoting the desired\nunderlying mapping as $\\hat{H}(x)$ , we let the stacked nonlinear\nlayers fit another mapping of $\\mathcal{F}(x)=\\hat{\\mathcal{F}}(x)-\\hat{H}(x)\\cdot x$ . The orig-\ninal mapping is recorded as $f(x)$ . We hypothesize that it\nis possible that the residual mapping may be the same as\nthe original, unreferenced mapping. To the extreme, if an\nidentity mapping were optimal, it would be easier to push\nthe residual to zero than to fit an identity mapping by a stack\nof nonlinear layers.",
          "bbox": [
            54,
            232,
            325,
            409
          ]
        },
        {
          "type": "paragraph",
          "content": "The formulation of $\\mathcal{F}(x) \\times x$ can be realized by feedfor-\nward neural networks with “ shortcut connections ” (Fig. 2 ).\nShortcut connections [22, 33, 48] are those skipping one or\nmore layers. In our case, the shortcut connections simply\nperform identity mapping, and their outputs are added to\nthe outputs of the stacked layers (Fig. 2 ). Identity short-\ncut connections add further extra parameters not com-\npletely learnable. They enhance the network and can be trained\nend-to-end by SGD with backpropagation, and can be eas-\nily implemented using common libraries ( e.g., Cafe [19] )\nwithout modifying the solvers.",
          "bbox": [
            54,
            409,
            325,
            560
          ]
        },
        {
          "type": "paragraph",
          "content": "We present comprehensive experiments on ImageNet\n[35] to show the degradation problem and evaluate our\nmethod. We show that: 1) Our extremely deep residual nets\nare easy to optimize, but the counterpart \"plain\" nets (that\nsimply stack layers) exhibit higher training error when the\ndepth decreases; 2) Our deep residual nets can easily enjoy\naccuracy gains from greatly increased depth, producing re-\nsults substantially better than previous networks.",
          "bbox": [
            54,
            560,
            325,
            669
          ]
        },
        {
          "type": "paragraph",
          "content": "Similar phenomena are also shown on the CIFAR-10 set\n[20] , suggesting that the optimization difficulties and the\neffects of our method are not just akin to a particular dataset.\nIn order to explore the impact of the training procedure, we look\nover 100 layers, and explore models with over 1000 layers.",
          "bbox": [
            54,
            670,
            325,
            739
          ]
        },
        {
          "type": "paragraph",
          "content": "On the ImageNet classification dataset [35] , we obtain\nexcellent results by extremely deep residual nets. Our 152-\nyear residual net is the deepest network ever present\nin ImageNet. In Table 1 , we show the error matrix of\nnets [40] . Our ensemble has 3.57 % top-5 error on the",
          "bbox": [
            54,
            740,
            325,
            808
          ]
        },
        {
          "type": "paragraph",
          "content": "ImageNet test set, and won the 1st place in the ILSVRC\n2015 classification competition. The extremely deep rep-\nresentations also have excellent generalization performance\non other recognition tasks, and lead us to further win the\n1st place on: ImageNet detection , ImageNet localization ,\nImageNet measurement , and ImageNet education . In\nCOCO 2015 competitions. This strong evidence shows that\nthe residual learning principle is generic, and we expect that\nit is applicable in other vision and non-vision problems.",
          "bbox": [
            346,
            82,
            618,
            205
          ]
        },
        {
          "type": "heading",
          "content": "2. Related Work",
          "bbox": [
            346,
            218,
            444,
            234
          ]
        },
        {
          "type": "paragraph",
          "content": "Residual Representations. In image recognition, VLD\n[18] is a representation that encodes by the residual vectors\nwith respect to a dictionary, and Fisher Vector [30] can be\nformulated as a probabilistic version [18] of VLD. Both\nof them are powerful shallow representations for image re-\ntrieval and classification [4, 47] . For vector quantization,\nencoding residual vectors [17] is shown to be more effec-\ntive than encoding original vectors.",
          "bbox": [
            346,
            242,
            618,
            352
          ]
        },
        {
          "type": "paragraph",
          "content": "In low-level vision and computer graphics, for solv-\ning Partial Differential Equations (PDEs), the widely used\nMultigrid method [3] reformulates the system as subprob-\nlems at multiple scales, where each subproblem is respon-\nsible for the residual solution between a coarser and a finer\nscale. An alternative to Multigrid is hierarchical basis pre-\nconditioning [44, 45] , which relies on variables that repre-\nsent residual vectors between two scales. It has been shown\n[3, 44, 45] that these solvers converge much faster than stan-\ndard solvers that are unaware of the residual nature of the\nsolutions. These methods suggest that a good reformulation\nor preconditioning can simplify the optimization.",
          "bbox": [
            346,
            352,
            618,
            516
          ]
        },
        {
          "type": "paragraph",
          "content": "Shortcut Connections. Practices and theories that lead to\nshortcut connections [2, 33, 48] have been studied for a long\ntime. An early practice of training multi-layer perceptrons\n(MLPs) is to add a linear layer connected from the network\ninput to the output [33, 48] . In [43, 24] , a few interme-\ndiates layers are directly connected to auxiliary classifiers\nfor additional learning/explaining/identifying. The papers\nof [25, 37, 31, 46] include a few more intermediate\nsponses, gradients, and propagated errors, implemented by\nshortcut connections. In [43] , an \"inception\" layer is com-\nposed of a shorter branch and a few deeper branches.",
          "bbox": [
            346,
            521,
            618,
            672
          ]
        },
        {
          "type": "paragraph",
          "content": "Concurrent with our work, “ highway networks ” [41, 42]\npresent shortcut connections with gating functions [15] .\nThese gates are data-dependent and have parameters, in\ncontrast to our identity shortcuts that are parameter-free.\nWhen a gated shortcut is “ closed ” (approaching zero), the\nlayers in highway networks represent non-residual func-\ntions. On the contrary, our formulation always learns\nresidual functions; our identity shortcuts are never closed,\nand all information is always passed through, with addi-\ntional residual functions to be learned. In addition, high-",
          "bbox": [
            346,
            672,
            618,
            808
          ]
        },
        {
          "type": "paragraph",
          "content": "1",
          "bbox": [
            337,
            856,
            353,
            869
          ]
        }
      ],
      "text": "[Figure]\n\nFigure 2. Residual learning: a building block.\n\nare comparably good or better than the constructed solution\n(or unable to do so in feasible time).\n\nIn this paper, we address the degradation problem by\nintroducing a deep residual learning framework. In-\nstead of hoping each few stacked layers directly fit a\ndesired underlying mapping, we explicitly let these lay-\ners fit a residual mapping. Formally, denoting the desired\nunderlying mapping as $\\hat{H}(x)$ , we let the stacked nonlinear\nlayers fit another mapping of $\\mathcal{F}(x)=\\hat{\\mathcal{F}}(x)-\\hat{H}(x)\\cdot x$ . The orig-\ninal mapping is recorded as $f(x)$ . We hypothesize that it\nis possible that the residual mapping may be the same as\nthe original, unreferenced mapping. To the extreme, if an\nidentity mapping were optimal, it would be easier to push\nthe residual to zero than to fit an identity mapping by a stack\nof nonlinear layers.\n\nThe formulation of $\\mathcal{F}(x) \\times x$ can be realized by feedfor-\nward neural networks with “ shortcut connections ” (Fig. 2 ).\nShortcut connections [22, 33, 48] are those skipping one or\nmore layers. In our case, the shortcut connections simply\nperform identity mapping, and their outputs are added to\nthe outputs of the stacked layers (Fig. 2 ). Identity short-\ncut connections add further extra parameters not com-\npletely learnable. They enhance the network and can be trained\nend-to-end by SGD with backpropagation, and can be eas-\nily implemented using common libraries ( e.g., Cafe [19] )\nwithout modifying the solvers.\n\nWe present comprehensive experiments on ImageNet\n[35] to show the degradation problem and evaluate our\nmethod. We show that: 1) Our extremely deep residual nets\nare easy to optimize, but the counterpart \"plain\" nets (that\nsimply stack layers) exhibit higher training error when the\ndepth decreases; 2) Our deep residual nets can easily enjoy\naccuracy gains from greatly increased depth, producing re-\nsults substantially better than previous networks.\n\nSimilar phenomena are also shown on the CIFAR-10 set\n[20] , suggesting that the optimization difficulties and the\neffects of our method are not just akin to a particular dataset.\nIn order to explore the impact of the training procedure, we look\nover 100 layers, and explore models with over 1000 layers.\n\nOn the ImageNet classification dataset [35] , we obtain\nexcellent results by extremely deep residual nets. Our 152-\nyear residual net is the deepest network ever present\nin ImageNet. In Table 1 , we show the error matrix of\nnets [40] . Our ensemble has 3.57 % top-5 error on the\n\nImageNet test set, and won the 1st place in the ILSVRC\n2015 classification competition. The extremely deep rep-\nresentations also have excellent generalization performance\non other recognition tasks, and lead us to further win the\n1st place on: ImageNet detection , ImageNet localization ,\nImageNet measurement , and ImageNet education . In\nCOCO 2015 competitions. This strong evidence shows that\nthe residual learning principle is generic, and we expect that\nit is applicable in other vision and non-vision problems.\n\n2. Related Work\n\nResidual Representations. In image recognition, VLD\n[18] is a representation that encodes by the residual vectors\nwith respect to a dictionary, and Fisher Vector [30] can be\nformulated as a probabilistic version [18] of VLD. Both\nof them are powerful shallow representations for image re-\ntrieval and classification [4, 47] . For vector quantization,\nencoding residual vectors [17] is shown to be more effec-\ntive than encoding original vectors.\n\nIn low-level vision and computer graphics, for solv-\ning Partial Differential Equations (PDEs), the widely used\nMultigrid method [3] reformulates the system as subprob-\nlems at multiple scales, where each subproblem is respon-\nsible for the residual solution between a coarser and a finer\nscale. An alternative to Multigrid is hierarchical basis pre-\nconditioning [44, 45] , which relies on variables that repre-\nsent residual vectors between two scales. It has been shown\n[3, 44, 45] that these solvers converge much faster than stan-\ndard solvers that are unaware of the residual nature of the\nsolutions. These methods suggest that a good reformulation\nor preconditioning can simplify the optimization.\n\nShortcut Connections. Practices and theories that lead to\nshortcut connections [2, 33, 48] have been studied for a long\ntime. An early practice of training multi-layer perceptrons\n(MLPs) is to add a linear layer connected from the network\ninput to the output [33, 48] . In [43, 24] , a few interme-\ndiates layers are directly connected to auxiliary classifiers\nfor additional learning/explaining/identifying. The papers\nof [25, 37, 31, 46] include a few more intermediate\nsponses, gradients, and propagated errors, implemented by\nshortcut connections. In [43] , an \"inception\" layer is com-\nposed of a shorter branch and a few deeper branches.\n\nConcurrent with our work, “ highway networks ” [41, 42]\npresent shortcut connections with gating functions [15] .\nThese gates are data-dependent and have parameters, in\ncontrast to our identity shortcuts that are parameter-free.\nWhen a gated shortcut is “ closed ” (approaching zero), the\nlayers in highway networks represent non-residual func-\ntions. On the contrary, our formulation always learns\nresidual functions; our identity shortcuts are never closed,\nand all information is always passed through, with addi-\ntional residual functions to be learned. In addition, high-\n\n1",
      "markdown": "![Figure 0](data:image/png;base64,[Figure])\n\nFigure 2. Residual learning: a building block.\n\nare comparably good or better than the constructed solution (or unable to do so in feasible time).\n\nIn this paper, we address the degradation problem by introducing a deep residual learning framework. Instead of hoping each few stacked layers directly fit a desired underlying mapping, we explicitly let these layers fit a residual mapping. Formally, denoting the desired underlying mapping as $\\hat{H}(x)$ , we let the stacked nonlinear layers fit another mapping of $\\mathcal{F}(x)=\\hat{\\mathcal{F}}(x)-\\hat{H}(x)\\cdot  x$ . The original mapping is recorded as $f(x)$ . We hypothesize that it is possible that the residual mapping may be the same as the original, unreferenced mapping. To the extreme, if an identity mapping were optimal, it would be easier to push the residual to zero than to fit an identity mapping by a stack of nonlinear layers.\n\nThe formulation of $\\mathcal{F}(x) \\times x$ can be realized by feedforward neural networks with “ shortcut connections ” (Fig. 2 ). Shortcut connections [22, 33, 48] are those skipping one or more layers. In our case, the shortcut connections simply perform identity mapping, and their outputs are added to the outputs of the stacked layers (Fig. 2 ). Identity shortcut connections add further extra parameters not completely learnable. They enhance the network and can be trained end-to-end by SGD with backpropagation, and can be easily implemented using common libraries ( e.g., Cafe [19] ) without modifying the solvers.\n\nWe present comprehensive experiments on ImageNet [35] to show the degradation problem and evaluate our method. We show that: 1) Our extremely deep residual nets are easy to optimize, but the counterpart \"plain\" nets (that simply stack layers) exhibit higher training error when the depth decreases; 2) Our deep residual nets can easily enjoy accuracy gains from greatly increased depth, producing results substantially better than previous networks.\n\nSimilar phenomena are also shown on the CIFAR-10 set [20] , suggesting that the optimization difficulties and the effects of our method are not just akin to a particular dataset. In order to explore the impact of the training procedure, we look over 100 layers, and explore models with over 1000 layers.\n\nOn the ImageNet classification dataset [35] , we obtain excellent results by extremely deep residual nets. Our 152year residual net is the deepest network ever present in ImageNet. In Table 1 , we show the error matrix of nets [40] . Our ensemble has 3.57 % top-5 error on the\n\nImageNet test set, and won the 1st place in the ILSVRC 2015 classification competition. The extremely deep representations also have excellent generalization performance on other recognition tasks, and lead us to further win the 1st place on: ImageNet detection , ImageNet localization , ImageNet measurement , and ImageNet education . In COCO 2015 competitions. This strong evidence shows that the residual learning principle is generic, and we expect that it is applicable in other vision and non-vision problems.\n\n## 2. Related Work\n\nResidual Representations. In image recognition, VLD [18] is a representation that encodes by the residual vectors with respect to a dictionary, and Fisher Vector [30] can be formulated as a probabilistic version [18] of VLD. Both of them are powerful shallow representations for image retrieval and classification [4, 47] . For vector quantization, encoding residual vectors [17] is shown to be more effective than encoding original vectors.\n\nIn low-level vision and computer graphics, for solving Partial Differential Equations (PDEs), the widely used Multigrid method [3] reformulates the system as subproblems at multiple scales, where each subproblem is responsible for the residual solution between a coarser and a finer scale. An alternative to Multigrid is hierarchical basis preconditioning [44, 45] , which relies on variables that represent residual vectors between two scales. It has been shown [3, 44, 45] that these solvers converge much faster than standard solvers that are unaware of the residual nature of the solutions. These methods suggest that a good reformulation or preconditioning can simplify the optimization.\n\nShortcut Connections. Practices and theories that lead to shortcut connections [2, 33, 48] have been studied for a long time. An early practice of training multi-layer perceptrons (MLPs) is to add a linear layer connected from the network input to the output [33, 48] . In [43, 24] , a few intermediates layers are directly connected to auxiliary classifiers for additional learning/explaining/identifying. The papers of [25, 37, 31, 46] include a few more intermediate sponses, gradients, and propagated errors, implemented by shortcut connections. In [43] , an \"inception\" layer is composed of a shorter branch and a few deeper branches.\n\nConcurrent with our work, “ highway networks ” [41, 42] present shortcut connections with gating functions [15] . These gates are data-dependent and have parameters, in contrast to our identity shortcuts that are parameter-free. When a gated shortcut is “ closed ” (approaching zero), the layers in highway networks represent non-residual functions. On the contrary, our formulation always learns residual functions; our identity shortcuts are never closed, and all information is always passed through, with additional residual functions to be learned. In addition, high-\n\n1\n\n"
    },
    {
      "page_number": 3,
      "elements": [
        {
          "type": "paragraph",
          "content": "way networks have not demonstrated accuracy gains with\nextremely increased depth (e.g., over 100 layers).",
          "bbox": [
            54,
            83,
            325,
            110
          ]
        },
        {
          "type": "heading",
          "content": "3. Deep Residual Learning",
          "bbox": [
            54,
            121,
            210,
            138
          ]
        },
        {
          "type": "subheading",
          "content": "3.1. Residual Learning",
          "bbox": [
            54,
            143,
            178,
            159
          ]
        },
        {
          "type": "paragraph",
          "content": "Let us consider $\\mathcal{H}(\\mathbf{x})$ as an underlying mapping to be\nfit by a few stacked layers (not necessarily the entire net),\nwith $\\mathbf{x}$ denoting the inputs to the first of these layers. If one\nhypothesizes that multiple nonlinear layers can asymptoti-\ncally approximate complicated functions$^{9}$ , then it is equiv-\nalent to hypothesize that they can asymptotically approxi-\nmate the residual functions, i.e., $\\mathcal{H}(\\mathbf{x}) - \\mathbf{x}$ (assuming that\nthe input and output are of the same dimensions). So\nrather than expect stacked layers to approximate $\\mathcal{H}(\\mathbf{x})$ , we\nexplicitly let these layers approximate a residual function\n$\\mathcal{F}(\\mathbf{x}) := \\mathcal{H}(\\mathbf{x}) - \\mathbf{x}$ . The original function thus becomes\n$\\mathcal{F}(\\mathbf{x}) + \\mathbf{x}$ . Although both forms should be able to asymptot-\nically approximate the desired functions (as hypothesized),\nthe ease of learning might be different.",
          "bbox": [
            54,
            165,
            325,
            355
          ]
        },
        {
          "type": "paragraph",
          "content": "This reformulation is motivated by the counterintuitive\nphenomena about the degradation problem (Fig. 1 , left). As\nwe discussed in the introduction, if the added layers can\nbe constructed as identity mappings, a deeper model should\nhave training error no greater than its shallower counter-\npart. The degradation problem suggests that the solvers\nneed to find a diffusion term appropriate for mapping\nby multiple nonlinear layers. With the residual error refor-\nmulation, if identity mappings are optimal, the solvers\nmay simply drive the weights of the multiple nonlinear lay-\ners toward zero to approach identity mappings.",
          "bbox": [
            54,
            355,
            325,
            504
          ]
        },
        {
          "type": "paragraph",
          "content": "In real cases, it is unlikely that identity mappings are op-\ntimal, but our reformulation may help to precondition the\nproblem. If the optimal function is closer to an identity\nmapping than to a zero mapping, it should be easier for the\nsolver to find the perturbations with reference to an identity\nmapping. This might be the case for the Identity Function\nby experiments (Fig. 7 ) that the learned residual functions in\ngeneral have small responses, suggesting that identity map-\npings provide reasonable preconditioning.",
          "bbox": [
            54,
            504,
            325,
            627
          ]
        },
        {
          "type": "subheading",
          "content": "3.2. Identity Mapping by Shortcut",
          "bbox": [
            54,
            633,
            238,
            649
          ]
        },
        {
          "type": "paragraph",
          "content": "We adopt residual learning to every few stacked layers.\nA building block is shown in Fig. 2 . Formally, in this paper\nwe consider a building block defined as:",
          "bbox": [
            54,
            655,
            325,
            697
          ]
        },
        {
          "type": "equation",
          "content": "$$\ny=\\mathcal{F}\\left(x,\\left\\{W_{i}\\right\\}\\right)+x . \\quad(1)\n$$",
          "bbox": [
            136,
            709,
            323,
            721
          ]
        },
        {
          "type": "paragraph",
          "content": "Here x and y are the input and output vectors of the lay-\ners considered. The function $\\mathcal{F}(x, W_i)$ represents the\nresidual mapping to be learned. For the example in Fig. 2 ,\nthat has two layers, $\\mathcal{F} = W_1 \\sigma(W_1 x)$ in which $\\sigma$ denotes",
          "bbox": [
            54,
            732,
            325,
            788
          ]
        },
        {
          "type": "paragraph",
          "content": "ReLU [29] and the biases are omitted for simplifying no-\ntations. The operation $\\mathcal{F}+x$ is performed by a shortcut\nconnection and element-wise addition. We adopt the sec-\nond nonlinearity after the addition (i.e., $\\sigma(y)$, see Fig. 2 ).",
          "bbox": [
            346,
            83,
            617,
            137
          ]
        },
        {
          "type": "paragraph",
          "content": "The shortcut connections in Eqn.(1) introduce neither ex-\ntra parameter nor computation complexity. This is not only\nattractive in practice but also important in our comparisons\nbetween plain and residual networks. We can fairly com-\nbine these advantages to get more advanced models with the\nsame number of parameters, depth, width, and computa-\ntional cost (except for the negligible element-wise addition).",
          "bbox": [
            346,
            137,
            618,
            232
          ]
        },
        {
          "type": "paragraph",
          "content": "The dimensions of $\\mathcal{X}$ and $\\mathcal{T}$ must be equal in Eqn.(1).\nIf this is not the case (e.g., when changing the input/output\nchannels), we can perform a linear projection $W_{s}$ by the\nshortcut connections to match the dimensions:",
          "bbox": [
            346,
            232,
            618,
            286
          ]
        },
        {
          "type": "equation",
          "content": "$$\ny=\\mathcal{F}\\left(x,\\left\\{W_{i}\\right\\}\\right)+W_{s} x . \\quad(2)\n$$",
          "bbox": [
            418,
            296,
            616,
            311
          ]
        },
        {
          "type": "paragraph",
          "content": "We can also use a square matrix $W_r$ in Eqn.(1). But we will\nshow by experiments that the identity mapping is sufficient\nfor addressing the degradation problem and is economical,\nand thus $W_r$ is only used when matching dimensions.",
          "bbox": [
            346,
            322,
            618,
            378
          ]
        },
        {
          "type": "paragraph",
          "content": "The form of the residual function $F$ is flexible. Exper-\niments in this paper involve a function $F$ that has two or\nthree parameters, and which is not simple. However, for\n$F$ has only a single layer, Eqn. (1) is similar to a linear layer:\n$y = W_1 x + x$ , for which we have not observed advantages.",
          "bbox": [
            346,
            379,
            618,
            446
          ]
        },
        {
          "type": "paragraph",
          "content": "We also note that although the above notations are about\nfully-connected layers for simplicity, they are applicable to\nconvolutional layers. The function $f(x,W_{i}^{j})$ can represent\na pair of $j$ -dimensional weights and $W_{i}^{j}$ is the weight matrix ded-\niction is performed on two feature maps, channel by channel.",
          "bbox": [
            346,
            446,
            618,
            513
          ]
        },
        {
          "type": "subheading",
          "content": "3.3. Network Architectures",
          "bbox": [
            346,
            521,
            493,
            537
          ]
        },
        {
          "type": "paragraph",
          "content": "We have tested various plain/residual nets, and have ob-\nserved consistent phenomena. To provide instances for dis-\ncussion, we describe two models for ImageNet as follows,",
          "bbox": [
            346,
            543,
            618,
            586
          ]
        },
        {
          "type": "paragraph",
          "content": "Plain Network. Our plain baselines (Fig. 3 , middle) are\nmainly inspired by the philosophy of VGG nets [40] (Fig. 3 ,\nleft). The convolutional layers mostly have 3×3 filters and\nfollow two simple design rules: (i) for the same output\nfeature map size, the layers have the same number of fil-\nters; and (ii) if the feature map size is halved, the num-\nber of filters is doubled so as to preserve the time com-\nplexity per layer. We perform downsampling directly by\nconvolutional layers that have a stride of 2. The network\nends with a global average pooling layer and a 1000-way-\nfully-connected layer with softmax. The total number of\nweighted layers is 34 in Fig. 3 (middle).",
          "bbox": [
            346,
            590,
            618,
            753
          ]
        },
        {
          "type": "paragraph",
          "content": "It is worth noting that our model has fewer filters and\nlower complexity than VGG nets [40] (Fig. 3 , left). Our 34-\nlayer baseline has 3.6 billion FLOPs (multiply-adds), which\nis only 18% of VGG-19 (9.6 billion FLOPs).",
          "bbox": [
            346,
            753,
            618,
            808
          ]
        },
        {
          "type": "footnote",
          "content": "$^{2}$This hypothesis, however, is still an open question. See [28].",
          "bbox": [
            66,
            794,
            293,
            807
          ]
        },
        {
          "type": "paragraph",
          "content": "1",
          "bbox": [
            337,
            860,
            354,
            872
          ]
        }
      ],
      "text": "way networks have not demonstrated accuracy gains with\nextremely increased depth (e.g., over 100 layers).\n\n3. Deep Residual Learning\n\n3.1. Residual Learning\n\nLet us consider $\\mathcal{H}(\\mathbf{x})$ as an underlying mapping to be\nfit by a few stacked layers (not necessarily the entire net),\nwith $\\mathbf{x}$ denoting the inputs to the first of these layers. If one\nhypothesizes that multiple nonlinear layers can asymptoti-\ncally approximate complicated functions$^{9}$ , then it is equiv-\nalent to hypothesize that they can asymptotically approxi-\nmate the residual functions, i.e., $\\mathcal{H}(\\mathbf{x}) - \\mathbf{x}$ (assuming that\nthe input and output are of the same dimensions). So\nrather than expect stacked layers to approximate $\\mathcal{H}(\\mathbf{x})$ , we\nexplicitly let these layers approximate a residual function\n$\\mathcal{F}(\\mathbf{x}) := \\mathcal{H}(\\mathbf{x}) - \\mathbf{x}$ . The original function thus becomes\n$\\mathcal{F}(\\mathbf{x}) + \\mathbf{x}$ . Although both forms should be able to asymptot-\nically approximate the desired functions (as hypothesized),\nthe ease of learning might be different.\n\nThis reformulation is motivated by the counterintuitive\nphenomena about the degradation problem (Fig. 1 , left). As\nwe discussed in the introduction, if the added layers can\nbe constructed as identity mappings, a deeper model should\nhave training error no greater than its shallower counter-\npart. The degradation problem suggests that the solvers\nneed to find a diffusion term appropriate for mapping\nby multiple nonlinear layers. With the residual error refor-\nmulation, if identity mappings are optimal, the solvers\nmay simply drive the weights of the multiple nonlinear lay-\ners toward zero to approach identity mappings.\n\nIn real cases, it is unlikely that identity mappings are op-\ntimal, but our reformulation may help to precondition the\nproblem. If the optimal function is closer to an identity\nmapping than to a zero mapping, it should be easier for the\nsolver to find the perturbations with reference to an identity\nmapping. This might be the case for the Identity Function\nby experiments (Fig. 7 ) that the learned residual functions in\ngeneral have small responses, suggesting that identity map-\npings provide reasonable preconditioning.\n\n3.2. Identity Mapping by Shortcut\n\nWe adopt residual learning to every few stacked layers.\nA building block is shown in Fig. 2 . Formally, in this paper\nwe consider a building block defined as:\n\n$$\ny=\\mathcal{F}\\left(x,\\left\\{W_{i}\\right\\}\\right)+x . \\quad(1)\n$$\n\nHere x and y are the input and output vectors of the lay-\ners considered. The function $\\mathcal{F}(x, W_i)$ represents the\nresidual mapping to be learned. For the example in Fig. 2 ,\nthat has two layers, $\\mathcal{F} = W_1 \\sigma(W_1 x)$ in which $\\sigma$ denotes\n\nReLU [29] and the biases are omitted for simplifying no-\ntations. The operation $\\mathcal{F}+x$ is performed by a shortcut\nconnection and element-wise addition. We adopt the sec-\nond nonlinearity after the addition (i.e., $\\sigma(y)$, see Fig. 2 ).\n\nThe shortcut connections in Eqn.(1) introduce neither ex-\ntra parameter nor computation complexity. This is not only\nattractive in practice but also important in our comparisons\nbetween plain and residual networks. We can fairly com-\nbine these advantages to get more advanced models with the\nsame number of parameters, depth, width, and computa-\ntional cost (except for the negligible element-wise addition).\n\nThe dimensions of $\\mathcal{X}$ and $\\mathcal{T}$ must be equal in Eqn.(1).\nIf this is not the case (e.g., when changing the input/output\nchannels), we can perform a linear projection $W_{s}$ by the\nshortcut connections to match the dimensions:\n\n$$\ny=\\mathcal{F}\\left(x,\\left\\{W_{i}\\right\\}\\right)+W_{s} x . \\quad(2)\n$$\n\nWe can also use a square matrix $W_r$ in Eqn.(1). But we will\nshow by experiments that the identity mapping is sufficient\nfor addressing the degradation problem and is economical,\nand thus $W_r$ is only used when matching dimensions.\n\nThe form of the residual function $F$ is flexible. Exper-\niments in this paper involve a function $F$ that has two or\nthree parameters, and which is not simple. However, for\n$F$ has only a single layer, Eqn. (1) is similar to a linear layer:\n$y = W_1 x + x$ , for which we have not observed advantages.\n\nWe also note that although the above notations are about\nfully-connected layers for simplicity, they are applicable to\nconvolutional layers. The function $f(x,W_{i}^{j})$ can represent\na pair of $j$ -dimensional weights and $W_{i}^{j}$ is the weight matrix ded-\niction is performed on two feature maps, channel by channel.\n\n3.3. Network Architectures\n\nWe have tested various plain/residual nets, and have ob-\nserved consistent phenomena. To provide instances for dis-\ncussion, we describe two models for ImageNet as follows,\n\nPlain Network. Our plain baselines (Fig. 3 , middle) are\nmainly inspired by the philosophy of VGG nets [40] (Fig. 3 ,\nleft). The convolutional layers mostly have 3×3 filters and\nfollow two simple design rules: (i) for the same output\nfeature map size, the layers have the same number of fil-\nters; and (ii) if the feature map size is halved, the num-\nber of filters is doubled so as to preserve the time com-\nplexity per layer. We perform downsampling directly by\nconvolutional layers that have a stride of 2. The network\nends with a global average pooling layer and a 1000-way-\nfully-connected layer with softmax. The total number of\nweighted layers is 34 in Fig. 3 (middle).\n\nIt is worth noting that our model has fewer filters and\nlower complexity than VGG nets [40] (Fig. 3 , left). Our 34-\nlayer baseline has 3.6 billion FLOPs (multiply-adds), which\nis only 18% of VGG-19 (9.6 billion FLOPs).\n\n$^{2}$This hypothesis, however, is still an open question. See [28].\n\n1",
      "markdown": "way networks have not demonstrated accuracy gains with extremely increased depth (e.g., over 100 layers).\n\n## 3. Deep Residual Learning\n\n### 3.1. Residual Learning\n\nLet us consider $\\mathcal{H}(\\mathbf{x})$ as an underlying mapping to be fit by a few stacked layers (not necessarily the entire net), with $\\mathbf{x}$ denoting the inputs to the first of these layers. If one hypothesizes that multiple nonlinear layers can asymptotically approximate complicated functions$^{9}$ , then it is equivalent to hypothesize that they can asymptotically approximate the residual functions, i.e., $\\mathcal{H}(\\mathbf{x}) - \\mathbf{x}$ (assuming that the input and output are of the same dimensions). So rather than expect stacked layers to approximate $\\mathcal{H}(\\mathbf{x})$ , we explicitly let these layers approximate a residual function $\\mathcal{F}(\\mathbf{x}) := \\mathcal{H}(\\mathbf{x}) - \\mathbf{x}$ . The original function thus becomes $\\mathcal{F}(\\mathbf{x}) + \\mathbf{x}$ . Although both forms should be able to asymptotically approximate the desired functions (as hypothesized), the ease of learning might be different.\n\nThis reformulation is motivated by the counterintuitive phenomena about the degradation problem (Fig. 1 , left). As we discussed in the introduction, if the added layers can be constructed as identity mappings, a deeper model should have training error no greater than its shallower counterpart. The degradation problem suggests that the solvers need to find a diffusion term appropriate for mapping by multiple nonlinear layers. With the residual error reformulation, if identity mappings are optimal, the solvers may simply drive the weights of the multiple nonlinear layers toward zero to approach identity mappings.\n\nIn real cases, it is unlikely that identity mappings are optimal, but our reformulation may help to precondition the problem. If the optimal function is closer to an identity mapping than to a zero mapping, it should be easier for the solver to find the perturbations with reference to an identity mapping. This might be the case for the Identity Function by experiments (Fig. 7 ) that the learned residual functions in general have small responses, suggesting that identity mappings provide reasonable preconditioning.\n\n### 3.2. Identity Mapping by Shortcut\n\nWe adopt residual learning to every few stacked layers. A building block is shown in Fig. 2 . Formally, in this paper we consider a building block defined as:\n\n$$\ny=\\mathcal{F}\\left(x,\\left\\{W_{i}\\right\\}\\right)+x . \\quad (1)\n$$\n\nHere x and y are the input and output vectors of the layers considered. The function $\\mathcal{F}(x, W_i)$ represents the residual mapping to be learned. For the example in Fig. 2 , that has two layers, $\\mathcal{F} = W_1 \\sigma(W_1 x)$ in which $\\sigma$ denotes\n\nReLU [29] and the biases are omitted for simplifying notations. The operation $\\mathcal{F}+x$ is performed by a shortcut connection and element-wise addition. We adopt the second nonlinearity after the addition (i.e., $\\sigma(y)$, see Fig. 2 ).\n\nThe shortcut connections in Eqn.(1) introduce neither extra parameter nor computation complexity. This is not only attractive in practice but also important in our comparisons between plain and residual networks. We can fairly combine these advantages to get more advanced models with the same number of parameters, depth, width, and computational cost (except for the negligible element-wise addition).\n\nThe dimensions of $\\mathcal{X}$ and $\\mathcal{T}$ must be equal in Eqn.(1). If this is not the case (e.g., when changing the input/output channels), we can perform a linear projection $W_{s}$ by the shortcut connections to match the dimensions:\n\n$$\ny=\\mathcal{F}\\left(x,\\left\\{W_{i}\\right\\}\\right)+W_{s} x . \\quad (2)\n$$\n\nWe can also use a square matrix $W_r$ in Eqn.(1). But we will show by experiments that the identity mapping is sufficient for addressing the degradation problem and is economical, and thus $W_r$ is only used when matching dimensions.\n\nThe form of the residual function $F$ is flexible. Experiments in this paper involve a function $F$ that has two or three parameters, and which is not simple. However, for $F$ has only a single layer, Eqn. (1) is similar to a linear layer: $y = W_1 x + x$ , for which we have not observed advantages.\n\nWe also note that although the above notations are about fully-connected layers for simplicity, they are applicable to convolutional layers. The function $f(x,W_{i}^{j})$ can represent a pair of $j$ -dimensional weights and $W_{i}^{j}$ is the weight matrix dediction is performed on two feature maps, channel by channel.\n\n### 3.3. Network Architectures\n\nWe have tested various plain/residual nets, and have observed consistent phenomena. To provide instances for discussion, we describe two models for ImageNet as follows,\n\nPlain Network. Our plain baselines (Fig. 3 , middle) are mainly inspired by the philosophy of VGG nets [40] (Fig. 3 , left). The convolutional layers mostly have 3×3 filters and follow two simple design rules: (i) for the same output feature map size, the layers have the same number of filters; and (ii) if the feature map size is halved, the number of filters is doubled so as to preserve the time complexity per layer. We perform downsampling directly by convolutional layers that have a stride of 2. The network ends with a global average pooling layer and a 1000-wayfully-connected layer with softmax. The total number of weighted layers is 34 in Fig. 3 (middle).\n\nIt is worth noting that our model has fewer filters and lower complexity than VGG nets [40] (Fig. 3 , left). Our 34layer baseline has 3.6 billion FLOPs (multiply-adds), which is only 18% of VGG-19 (9.6 billion FLOPs).\n\n$^{2}$This hypothesis, however, is still an open question. See [28].\n\n1\n\n"
    },
    {
      "page_number": 4,
      "elements": [
        {
          "type": "figure",
          "content": "[Figure]",
          "bbox": [
            53,
            85,
            327,
            706
          ]
        },
        {
          "type": "paragraph",
          "content": "Figure 3. Example network architectures for ImageNet. Left: the\nViGG-19 model [40] (19.6 billion FLOPs) as a reference. Mid-\ndle: a plain network with 34 parameter layers (3.6 billion FLOPs).\nRight: a residual network with 34 parameter layers (3.6 billion\nFLOPs). The dotted shortcuts increase dimensions. Table 1 shows\nmore details and other variants.",
          "bbox": [
            55,
            714,
            325,
            789
          ]
        },
        {
          "type": "paragraph",
          "content": "Residual Network. Based on the above plain network, we\ninsert shortcut connections (Fig. 3 , right) which turn the\nnetwork into its counterpart residual version. The identity\nshortcuts (Eqn.(1) can be directly used when the input and\noutput are of the same dimensions (solid line shortcuts in\nFig. 3 ). When the dimensions increase (dotted line shortcuts\nin Fig. 5 ), we consider two options: (A) The shortcut still\nworks but the performance is slightly worse due to the loss\nfor increasing dimensions. This option introduces no extra\nparameter; (B) The projection shortcut in Eqn.(2) is used to\nmatch dimensions (done by $1 \\times 1$ convolutions). For both\noptions, when the shortcuts go across feature maps of two\nsizes, they are performed with a stride of 2.",
          "bbox": [
            346,
            83,
            618,
            259
          ]
        },
        {
          "type": "subheading",
          "content": "3.4. Implementation",
          "bbox": [
            347,
            265,
            453,
            281
          ]
        },
        {
          "type": "paragraph",
          "content": "Our implementation for ImageNet follows the practice\nin [21, 40] . The image is resized with its shorter side ran-\ndomly sampled in [26, 40] , for scale augmentation [40] .\nA 224×224 crop is randomly sampled from an image or its\nhorizontal flip, with the per-pixel mean subtracted [21] . The\nstandard color augmentation in [21] is used. We adopt batch\nnormalization (BN) [16] right after each convolution and\nbefore activation, following [16] . We initialize the weights\nas in [12] and train all plain/residual nets from scratch. We\nuse SGD with a mini-batch size of 256. The learning rate\nstarts from 0.1 and is divided by 10 when the error plateaus,\nand the models are trained for up to $60 \\times 10^4$ iterations. We\nuse a weight decay of 0.0001 and a momentum of 0.9. We\ndo not use dropout [13] , following the practice in [16] .",
          "bbox": [
            347,
            286,
            618,
            477
          ]
        },
        {
          "type": "paragraph",
          "content": "In testing, for comparison studies we adopt the standard\n10-copy testing [21] . For best results, we adopt the fully-\nformal form [40, 48, 12] , and average the scores\nat multiple settings were averaged such that the shorter\nside is $\\{22, 256, 384, 489, 640\\}$ .",
          "bbox": [
            347,
            477,
            618,
            543
          ]
        },
        {
          "type": "heading",
          "content": "4. Experiments",
          "bbox": [
            347,
            553,
            437,
            571
          ]
        },
        {
          "type": "subheading",
          "content": "4.1. ImageNet Classification",
          "bbox": [
            347,
            577,
            498,
            593
          ]
        },
        {
          "type": "paragraph",
          "content": "We evaluate our method on the ImageNet 2012 classifi-\ncation dataset [35] that consists of 1000 classes. The models\nare trained on the 1.28 million training images, and evalu-\nated on the 50k validation images. We also obtain a final\nresult on the 100k test images, reported by the test server.\nWe evaluate both top-1 and top-5 error rates.",
          "bbox": [
            347,
            597,
            617,
            680
          ]
        },
        {
          "type": "paragraph",
          "content": "Plain Networks. We first evaluate 18-layer and 34-layer\nplain nets. The 34-layer plain net is in Fig. 3 (middle). The\n18-layer plain net is of a similar form. See Table 1 for de-\ntailed architectures.",
          "bbox": [
            347,
            685,
            617,
            740
          ]
        },
        {
          "type": "paragraph",
          "content": "The results in Table 2 show that the deeper 34-layer plain\nnet has higher validation error than the shallower 18-layer\nplain net. To reveal the reason, in Fig. 7 (left) we com-\npare it with another convolutional network and the indi-\ncedure. We have observed the degradation problem + the",
          "bbox": [
            347,
            740,
            618,
            808
          ]
        },
        {
          "type": "paragraph",
          "content": "1",
          "bbox": [
            337,
            858,
            353,
            871
          ]
        }
      ],
      "text": "[Figure]\n\nFigure 3. Example network architectures for ImageNet. Left: the\nViGG-19 model [40] (19.6 billion FLOPs) as a reference. Mid-\ndle: a plain network with 34 parameter layers (3.6 billion FLOPs).\nRight: a residual network with 34 parameter layers (3.6 billion\nFLOPs). The dotted shortcuts increase dimensions. Table 1 shows\nmore details and other variants.\n\nResidual Network. Based on the above plain network, we\ninsert shortcut connections (Fig. 3 , right) which turn the\nnetwork into its counterpart residual version. The identity\nshortcuts (Eqn.(1) can be directly used when the input and\noutput are of the same dimensions (solid line shortcuts in\nFig. 3 ). When the dimensions increase (dotted line shortcuts\nin Fig. 5 ), we consider two options: (A) The shortcut still\nworks but the performance is slightly worse due to the loss\nfor increasing dimensions. This option introduces no extra\nparameter; (B) The projection shortcut in Eqn.(2) is used to\nmatch dimensions (done by $1 \\times 1$ convolutions). For both\noptions, when the shortcuts go across feature maps of two\nsizes, they are performed with a stride of 2.\n\n3.4. Implementation\n\nOur implementation for ImageNet follows the practice\nin [21, 40] . The image is resized with its shorter side ran-\ndomly sampled in [26, 40] , for scale augmentation [40] .\nA 224×224 crop is randomly sampled from an image or its\nhorizontal flip, with the per-pixel mean subtracted [21] . The\nstandard color augmentation in [21] is used. We adopt batch\nnormalization (BN) [16] right after each convolution and\nbefore activation, following [16] . We initialize the weights\nas in [12] and train all plain/residual nets from scratch. We\nuse SGD with a mini-batch size of 256. The learning rate\nstarts from 0.1 and is divided by 10 when the error plateaus,\nand the models are trained for up to $60 \\times 10^4$ iterations. We\nuse a weight decay of 0.0001 and a momentum of 0.9. We\ndo not use dropout [13] , following the practice in [16] .\n\nIn testing, for comparison studies we adopt the standard\n10-copy testing [21] . For best results, we adopt the fully-\nformal form [40, 48, 12] , and average the scores\nat multiple settings were averaged such that the shorter\nside is $\\{22, 256, 384, 489, 640\\}$ .\n\n4. Experiments\n\n4.1. ImageNet Classification\n\nWe evaluate our method on the ImageNet 2012 classifi-\ncation dataset [35] that consists of 1000 classes. The models\nare trained on the 1.28 million training images, and evalu-\nated on the 50k validation images. We also obtain a final\nresult on the 100k test images, reported by the test server.\nWe evaluate both top-1 and top-5 error rates.\n\nPlain Networks. We first evaluate 18-layer and 34-layer\nplain nets. The 34-layer plain net is in Fig. 3 (middle). The\n18-layer plain net is of a similar form. See Table 1 for de-\ntailed architectures.\n\nThe results in Table 2 show that the deeper 34-layer plain\nnet has higher validation error than the shallower 18-layer\nplain net. To reveal the reason, in Fig. 7 (left) we com-\npare it with another convolutional network and the indi-\ncedure. We have observed the degradation problem + the\n\n1",
      "markdown": "![Figure 0](data:image/png;base64,[Figure])\n\nFigure 3. Example network architectures for ImageNet. Left: the ViGG-19 model [40] (19.6 billion FLOPs) as a reference. Middle: a plain network with 34 parameter layers (3.6 billion FLOPs). Right: a residual network with 34 parameter layers (3.6 billion FLOPs). The dotted shortcuts increase dimensions. Table 1 shows more details and other variants.\n\nResidual Network. Based on the above plain network, we insert shortcut connections (Fig. 3 , right) which turn the network into its counterpart residual version. The identity shortcuts (Eqn.(1) can be directly used when the input and output are of the same dimensions (solid line shortcuts in Fig. 3 ). When the dimensions increase (dotted line shortcuts in Fig. 5 ), we consider two options: (A) The shortcut still works but the performance is slightly worse due to the loss for increasing dimensions. This option introduces no extra parameter; (B) The projection shortcut in Eqn.(2) is used to match dimensions (done by $1 \\times 1$ convolutions). For both options, when the shortcuts go across feature maps of two sizes, they are performed with a stride of 2.\n\n### 3.4. Implementation\n\nOur implementation for ImageNet follows the practice in [21, 40] . The image is resized with its shorter side randomly sampled in [26, 40] , for scale augmentation [40] . A 224×224 crop is randomly sampled from an image or its horizontal flip, with the per-pixel mean subtracted [21] . The standard color augmentation in [21] is used. We adopt batch normalization (BN) [16] right after each convolution and before activation, following [16] . We initialize the weights as in [12] and train all plain/residual nets from scratch. We use SGD with a mini-batch size of 256. The learning rate starts from 0.1 and is divided by 10 when the error plateaus, and the models are trained for up to $60 \\times 10^4$ iterations. We use a weight decay of 0.0001 and a momentum of 0.9. We do not use dropout [13] , following the practice in [16] .\n\nIn testing, for comparison studies we adopt the standard 10-copy testing [21] . For best results, we adopt the fullyformal form [40, 48, 12] , and average the scores at multiple settings were averaged such that the shorter side is $\\{22, 256, 384, 489, 640\\}$ .\n\n## 4. Experiments\n\n### 4.1. ImageNet Classification\n\nWe evaluate our method on the ImageNet 2012 classification dataset [35] that consists of 1000 classes. The models are trained on the 1.28 million training images, and evaluated on the 50k validation images. We also obtain a final result on the 100k test images, reported by the test server. We evaluate both top-1 and top-5 error rates.\n\nPlain Networks. We first evaluate 18-layer and 34-layer plain nets. The 34-layer plain net is in Fig. 3 (middle). The 18-layer plain net is of a similar form. See Table 1 for detailed architectures.\n\nThe results in Table 2 show that the deeper 34-layer plain net has higher validation error than the shallower 18-layer plain net. To reveal the reason, in Fig. 7 (left) we compare it with another convolutional network and the indicedure. We have observed the degradation problem + the\n\n1\n\n"
    },
    {
      "page_number": 5,
      "elements": [
        {
          "type": "table",
          "content": "<table><tr><td>layer name</td><td>output size</td><td>18-layer</td><td>34-layer</td><td>50-layer</td><td>101-layer</td><td>152-layer</td></tr><tr><td>conv1</td><td>112×112</td><td colspan=\"5\">3×3 matlab, stride 2</td></tr><tr><td>conv2_x</td><td>56×56</td><td>{3×3, 64×3×3, 64}</td><td>{3×3, 64×3×3, 64}</td><td>{1×1, 64×3×3, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64,",
          "bbox": [
            141,
            81,
            529,
            249
          ]
        },
        {
          "type": "paragraph",
          "content": "Table 1. Architectures for ImageNet: Building blocks are shown in brackets (see also Fig. 5), with the numbers of blocks stacked. Down-\nsampling is performed by conv3, conv4, 1, and conv5_1 with a stride of 2.",
          "bbox": [
            53,
            252,
            617,
            279
          ]
        },
        {
          "type": "figure",
          "content": "[Figure]",
          "bbox": [
            94,
            283,
            574,
            440
          ]
        },
        {
          "type": "paragraph",
          "content": "Figure 4. Training on ImageNet. This curve denotes training error, and bold curves denote validation error of the center crop. Left: plain\nresiduals for all four layers; Right: ResNets of 18 and 54 layers. In this plot, the residual networks have no extra parameters compared to\ntheir plain counterparts.",
          "bbox": [
            54,
            442,
            617,
            480
          ]
        },
        {
          "type": "table",
          "content": "<table><tr><td>18 layers</td><td>plain</td><td>ResNet</td></tr><tr><td>25 layers</td><td>26.05</td><td>26.23</td></tr><tr><td>34 layers</td><td>28.54</td><td>25.03</td></tr></table>",
          "bbox": [
            104,
            501,
            270,
            541
          ]
        },
        {
          "type": "paragraph",
          "content": "Table 2. Top-1 error ( % ) -10-cp test results on ImageNet validation.\nTop-1 error is the average value of all the columns excepting for their plain\ncounterparts. Fig. 4 shows the training procedures.",
          "bbox": [
            54,
            547,
            325,
            586
          ]
        },
        {
          "type": "paragraph",
          "content": "34-layer plain net has higher training error throughout the\nwhole training procedure, even though the solution space\nof the 18-layer plain network is a subspace of that of the\n34-layer one.",
          "bbox": [
            54,
            615,
            325,
            670
          ]
        },
        {
          "type": "paragraph",
          "content": "We argue that this optimization difficulty is unlikely to\nbe caused by vanishing gradients. These plain networks are\ntrained with BN [16] , which ensures forward propagated\nsignals to have non-zero variances. We also verify that the\nbackward propagated gradients exhibit healthy norms with\nBN. So neither forward nor backward signals vanish. In\nfact, the 34-layer plain net is still able to achieve compet-\nitive accuracy (Table 3 ), suggesting that the solver works\nto some extent. We conjecture that the deep plain nets may\nhave exponentially low convergence rates, which impact the",
          "bbox": [
            54,
            672,
            325,
            808
          ]
        },
        {
          "type": "paragraph",
          "content": "reducing of the training error). The reason for such opti-\nmization difficulties will be studied in the future.",
          "bbox": [
            346,
            500,
            617,
            530
          ]
        },
        {
          "type": "paragraph",
          "content": "Residual Networks. Next we evaluate 18-layer and 34-\nlayer residual nets (ResNets). The baseline architectures\nare the same as the above plain nets, expect that a shortcut\nconnection is added to each pair of 3 $\\times$ 3 filters as in Fig. 3\n(right). In the first comparison (Table 2 and Fig. 4 right),\nwe use identity mapping for all shortcuts and zero-padding\nfor increasing dimensions (option A), so they have no extra\nparameter compared to the plain counterparts.",
          "bbox": [
            346,
            535,
            618,
            644
          ]
        },
        {
          "type": "paragraph",
          "content": "We have three major observations from Table 2 and\nFig. 4 . First, the situation is reversed with residual learn-\ning – the 34-layer ResNet is better than the 18-layer ResNet\n(by 2.8 % ). More importantly, the 34-layer ResNet exhibits\nconsiderably lower training error and is generalizable to the\nvalidation data. This indicates that the degradation problem\nis well addressed in this setting and we manage to obtain\naccuracy gains from increased depth.",
          "bbox": [
            346,
            644,
            618,
            751
          ]
        },
        {
          "type": "paragraph",
          "content": "Second, compared to its plain counterpart, the 34-layer",
          "bbox": [
            358,
            751,
            617,
            766
          ]
        },
        {
          "type": "footnote",
          "content": "We have experimented with more training iterations (3×) and still ob-\nserved that the increase in the number of training iterations can be\nfeasibly addressed by simply using more training.",
          "bbox": [
            347,
            773,
            617,
            807
          ]
        },
        {
          "type": "paragraph",
          "content": "774",
          "bbox": [
            336,
            831,
            355,
            843
          ]
        }
      ],
      "text": "<table><tr><td>layer name</td><td>output size</td><td>18-layer</td><td>34-layer</td><td>50-layer</td><td>101-layer</td><td>152-layer</td></tr><tr><td>conv1</td><td>112×112</td><td colspan=\"5\">3×3 matlab, stride 2</td></tr><tr><td>conv2_x</td><td>56×56</td><td>{3×3, 64×3×3, 64}</td><td>{3×3, 64×3×3, 64}</td><td>{1×1, 64×3×3, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64,\n\nTable 1. Architectures for ImageNet: Building blocks are shown in brackets (see also Fig. 5), with the numbers of blocks stacked. Down-\nsampling is performed by conv3, conv4, 1, and conv5_1 with a stride of 2.\n\n[Figure]\n\nFigure 4. Training on ImageNet. This curve denotes training error, and bold curves denote validation error of the center crop. Left: plain\nresiduals for all four layers; Right: ResNets of 18 and 54 layers. In this plot, the residual networks have no extra parameters compared to\ntheir plain counterparts.\n\n<table><tr><td>18 layers</td><td>plain</td><td>ResNet</td></tr><tr><td>25 layers</td><td>26.05</td><td>26.23</td></tr><tr><td>34 layers</td><td>28.54</td><td>25.03</td></tr></table>\n\nTable 2. Top-1 error ( % ) -10-cp test results on ImageNet validation.\nTop-1 error is the average value of all the columns excepting for their plain\ncounterparts. Fig. 4 shows the training procedures.\n\n34-layer plain net has higher training error throughout the\nwhole training procedure, even though the solution space\nof the 18-layer plain network is a subspace of that of the\n34-layer one.\n\nWe argue that this optimization difficulty is unlikely to\nbe caused by vanishing gradients. These plain networks are\ntrained with BN [16] , which ensures forward propagated\nsignals to have non-zero variances. We also verify that the\nbackward propagated gradients exhibit healthy norms with\nBN. So neither forward nor backward signals vanish. In\nfact, the 34-layer plain net is still able to achieve compet-\nitive accuracy (Table 3 ), suggesting that the solver works\nto some extent. We conjecture that the deep plain nets may\nhave exponentially low convergence rates, which impact the\n\nreducing of the training error). The reason for such opti-\nmization difficulties will be studied in the future.\n\nResidual Networks. Next we evaluate 18-layer and 34-\nlayer residual nets (ResNets). The baseline architectures\nare the same as the above plain nets, expect that a shortcut\nconnection is added to each pair of 3 $\\times$ 3 filters as in Fig. 3\n(right). In the first comparison (Table 2 and Fig. 4 right),\nwe use identity mapping for all shortcuts and zero-padding\nfor increasing dimensions (option A), so they have no extra\nparameter compared to the plain counterparts.\n\nWe have three major observations from Table 2 and\nFig. 4 . First, the situation is reversed with residual learn-\ning – the 34-layer ResNet is better than the 18-layer ResNet\n(by 2.8 % ). More importantly, the 34-layer ResNet exhibits\nconsiderably lower training error and is generalizable to the\nvalidation data. This indicates that the degradation problem\nis well addressed in this setting and we manage to obtain\naccuracy gains from increased depth.\n\nSecond, compared to its plain counterpart, the 34-layer\n\nWe have experimented with more training iterations (3×) and still ob-\nserved that the increase in the number of training iterations can be\nfeasibly addressed by simply using more training.\n\n774",
      "markdown": "\n\n\nTable 1. Architectures for ImageNet: Building blocks are shown in brackets (see also Fig. 5), with the numbers of blocks stacked. Downsampling is performed by conv3, conv4, 1, and conv5_1 with a stride of 2.\n\n![Figure 2](data:image/png;base64,[Figure])\n\nFigure 4. Training on ImageNet. This curve denotes training error, and bold curves denote validation error of the center crop. Left: plain residuals for all four layers; Right: ResNets of 18 and 54 layers. In this plot, the residual networks have no extra parameters compared to their plain counterparts.\n\n<table><tr><td>18 layers</td><td>plain</td><td>ResNet</td></tr><tr><td>25 layers</td><td>26.05</td><td>26.23</td></tr><tr><td>34 layers</td><td>28.54</td><td>25.03</td></tr></table>\n\n\nTable 2. Top-1 error ( % ) -10-cp test results on ImageNet validation. Top-1 error is the average value of all the columns excepting for their plain counterparts. Fig. 4 shows the training procedures.\n\n34-layer plain net has higher training error throughout the whole training procedure, even though the solution space of the 18-layer plain network is a subspace of that of the 34-layer one.\n\nWe argue that this optimization difficulty is unlikely to be caused by vanishing gradients. These plain networks are trained with BN [16] , which ensures forward propagated signals to have non-zero variances. We also verify that the backward propagated gradients exhibit healthy norms with BN. So neither forward nor backward signals vanish. In fact, the 34-layer plain net is still able to achieve competitive accuracy (Table 3 ), suggesting that the solver works to some extent. We conjecture that the deep plain nets may have exponentially low convergence rates, which impact the\n\nreducing of the training error). The reason for such optimization difficulties will be studied in the future.\n\nResidual Networks. Next we evaluate 18-layer and 34layer residual nets (ResNets). The baseline architectures are the same as the above plain nets, expect that a shortcut connection is added to each pair of 3 $\\times$ 3 filters as in Fig. 3 (right). In the first comparison (Table 2 and Fig. 4 right), we use identity mapping for all shortcuts and zero-padding for increasing dimensions (option A), so they have no extra parameter compared to the plain counterparts.\n\nWe have three major observations from Table 2 and Fig. 4 . First, the situation is reversed with residual learning – the 34-layer ResNet is better than the 18-layer ResNet (by 2.8 % ). More importantly, the 34-layer ResNet exhibits considerably lower training error and is generalizable to the validation data. This indicates that the degradation problem is well addressed in this setting and we manage to obtain accuracy gains from increased depth.\n\nSecond, compared to its plain counterpart, the 34-layer\n\nWe have experimented with more training iterations (3×) and still observed that the increase in the number of training iterations can be feasibly addressed by simply using more training.\n\n774\n\n"
    },
    {
      "page_number": 6,
      "elements": [
        {
          "type": "table",
          "content": "<table><tr><td>model</td><td>top-1 err.</td><td>top-5 err.</td></tr><tr><td>VGG-16 [40]</td><td>28.07</td><td>9.33</td></tr><tr><td>GoogleLeNet [43]</td><td>-</td><td>9.15</td></tr><tr><td>PReLU-Net [12]</td><td>24.27</td><td>7.38</td></tr><tr><td>plain-34</td><td>28.54</td><td>10.02</td></tr><tr><td>ResNet-34 A</td><td>25.03</td><td>7.76</td></tr><tr><td>ResNet-34 B</td><td>24.52</td><td>7.46</td></tr><tr><td>ResNet-50</td><td>24.40</td><td>6.92</td></tr><tr><td>ResNet-50</td><td>22.85</td><td>6.71</td></tr><tr><td>ResNet-101</td><td>21.75</td><td>6.05</td></tr><tr><td>ResNet-152</td><td>21.43</td><td>5.71</td></tr></table>",
          "bbox": [
            99,
            82,
            280,
            234
          ]
        },
        {
          "type": "paragraph",
          "content": "Table 3. Error rates (%) -10-copy testing in ImageNet validation.\nWe find that the mean and minimum values of option B\nthat only uses projections for increasing dimensions.",
          "bbox": [
            55,
            240,
            325,
            279
          ]
        },
        {
          "type": "table",
          "content": "<table><tr><td>method</td><td>top-1 err.</td><td>top-5</td></tr><tr><td>VGG [40] (ILSVRC'14)</td><td>-</td><td>8.43</td></tr><tr><td>GoogLeNet [43] (ILSVRC'14)</td><td>-</td><td>7.89</td></tr><tr><td>VGG [40] (v5)</td><td>24.4</td><td>7.1</td></tr><tr><td>PReLU-net [12]</td><td>21.59</td><td>5.77</td></tr><tr><td>BN-incoption [16]</td><td>21.99</td><td>5.8</td></tr><tr><td>ResNet-34 B</td><td>21.84</td><td>5.77</td></tr><tr><td>ResNet-34 C</td><td>21.53</td><td>5.66</td></tr><tr><td>ResNet-101</td><td>20.74</td><td>5.2</td></tr><tr><td>ResNet-101</td><td>19.87</td><td>4.66</td></tr><tr><td>ResNet-152</td><td>19.38</td><td>4.48</td></tr></table>",
          "bbox": [
            68,
            287,
            293,
            439
          ]
        },
        {
          "type": "paragraph",
          "content": "Table 4. Error rates (%) of single-model results on the ImageNet\nvalidation set (except reported on the test set).",
          "bbox": [
            55,
            445,
            325,
            472
          ]
        },
        {
          "type": "table",
          "content": "<table><tr><td>method</td><td>top-5 err. (test)</td></tr><tr><td>VGG [40] (ILSVRC'14)</td><td>7.32</td></tr><tr><td>GoogLeNet [43] (ILSVRC'14)</td><td>6.66</td></tr><tr><td>VGG [40] (v5)</td><td>6.8</td></tr><tr><td>PReLU-net [12]</td><td>4.94</td></tr><tr><td>BN-inception [16]</td><td>4.82</td></tr><tr><td>ResNet (ILSVRC'15)</td><td>3.57</td></tr></table>",
          "bbox": [
            72,
            480,
            311,
            578
          ]
        },
        {
          "type": "paragraph",
          "content": "Table 5. Error rates (%) of ensembles . The top-5 error is on the\ntest set of ImageNet and reported by the test server.",
          "bbox": [
            55,
            584,
            325,
            610
          ]
        },
        {
          "type": "paragraph",
          "content": "ResNet reduces the top-1 error by 3.5 % (Table 2 ), resulting\nfrom the successfully reduced training error (Fig. 4 right vs.\nleft). This comparison verifies the effectiveness of residual\nlearning on extremely deep systems.",
          "bbox": [
            55,
            634,
            326,
            689
          ]
        },
        {
          "type": "paragraph",
          "content": "Last, we also note that the 18-layer plain-residual nets\nare comparably accurate (Table 2 ), but the 18-layer ResNet\nconverges faster (Fig. 4 right vs. left). When the net is \"not\noverly deep\" (18 layers here), the current SGD solver is still\nrelatively insensitive to the plain net. In this case, the\nResNet eases the optimization by providing faster conver-\ngence at the early stage.",
          "bbox": [
            55,
            689,
            326,
            786
          ]
        },
        {
          "type": "paragraph",
          "content": "Identity vs. Projection Shortcuts. We have shown that",
          "bbox": [
            55,
            792,
            326,
            808
          ]
        },
        {
          "type": "paragraph",
          "content": "parameter-free, identity shortcuts help with training. Next\nwe investigate projection shortcuts (Eqn.(2)). In Table 3 we\ncompare three options: (A) zero-padding shortcuts are used\nfor increasing dimensions, and all shortcuts are parameter-\nized; (B) one or two parameterized shortcuts are used for in-\ntion shortcuts are used for increasing dimensions, and other\nshortcuts are identity; and (C) all shortcuts are projections.",
          "bbox": [
            346,
            230,
            618,
            326
          ]
        },
        {
          "type": "figure",
          "content": "[Figure]",
          "bbox": [
            374,
            80,
            604,
            165
          ]
        },
        {
          "type": "paragraph",
          "content": "Figure 5: A deeper residual function $F$ for ImageNet, Left: self-attention\nblock, Right: “a bottleneck” build-on block for ResNet-50v1 [19]",
          "bbox": [
            346,
            175,
            617,
            214
          ]
        },
        {
          "type": "paragraph",
          "content": "Table 3 shows that all three options are considerable bet-\nter than the plain counterpart. B is slightly better than A. We\nargue that this is because the zero-padded dimensions in A\nindeed have no residual learning. C is marginally better than\nB, and we attribute this to the extra parameters introduced\nby many (thirteen) projection shortcuts. But the small dif-\nferences among A/B/C indicate that projection shortcuts are\nnot essential for addressing the degradation problem. So we\ndo not use option C in the rest of this paper, to reduce mem-\nory/time complexity and model sizes. Identify shortcuts are\nparticularly important for not increasing the complexity of\nthe bottleneck architectures that are introduced below.",
          "bbox": [
            346,
            327,
            618,
            489
          ]
        },
        {
          "type": "paragraph",
          "content": "Deeper Bottleneck Architectures. Next we describe our\ndeeper nets for ImageNet. Because of concerns on the train-\ning time that we can afford, we modify the building block\nas a bottleneck design $^4$ . For each residual function $\\mathcal{F}$ , we\nuse a stack of 3 layers instead of 2 (Fig. 5 ). The three layers\nare $1 \\times 1, 3 \\times 3$ , and $1 \\times 1$ convolutions, where the $1 \\times 1$ layers\nare responsible for reducing and then increasing (restoring)\ndimensions, leaving the $3 \\times 3$ layer a bottleneck with smaller\ninput/output dimensions. Fig. 5 shows an example, where\nboth designs have similar time complexity.",
          "bbox": [
            346,
            495,
            618,
            632
          ]
        },
        {
          "type": "paragraph",
          "content": "The parameter-free identity shortcuts are particularly im-\nportant for the bottleneck architectures. If the identity short-\ncut in Fig. 5 (right) is replaced with projection, one can\nshow that the time complexity and model size are doubled,\nand the computation time is doubled compared to the two high-dimensional\nends. So identity shortcuts lead to more efficient models\nfor the bottleneck designs.",
          "bbox": [
            346,
            632,
            618,
            727
          ]
        },
        {
          "type": "paragraph",
          "content": "ResNet-50:",
          "bbox": [
            346,
            727,
            617,
            742
          ]
        },
        {
          "type": "footnote",
          "content": "$^{*}$Deeper non-bottleneck ResNets (e.g., Fig. 5 left) also gain accuracy\nfrom increased depth (as shown in CIFAR-10), but are not as economical\nas the bottleneck ResNets. So the usage of bottleneck designs is mainly due\nto the breadth and performance limitations of the original implementation\nof plain nets is also witnessed for the bottleneck design.",
          "bbox": [
            346,
            752,
            617,
            807
          ]
        },
        {
          "type": "paragraph",
          "content": "1",
          "bbox": [
            336,
            858,
            354,
            871
          ]
        }
      ],
      "text": "<table><tr><td>model</td><td>top-1 err.</td><td>top-5 err.</td></tr><tr><td>VGG-16 [40]</td><td>28.07</td><td>9.33</td></tr><tr><td>GoogleLeNet [43]</td><td>-</td><td>9.15</td></tr><tr><td>PReLU-Net [12]</td><td>24.27</td><td>7.38</td></tr><tr><td>plain-34</td><td>28.54</td><td>10.02</td></tr><tr><td>ResNet-34 A</td><td>25.03</td><td>7.76</td></tr><tr><td>ResNet-34 B</td><td>24.52</td><td>7.46</td></tr><tr><td>ResNet-50</td><td>24.40</td><td>6.92</td></tr><tr><td>ResNet-50</td><td>22.85</td><td>6.71</td></tr><tr><td>ResNet-101</td><td>21.75</td><td>6.05</td></tr><tr><td>ResNet-152</td><td>21.43</td><td>5.71</td></tr></table>\n\nTable 3. Error rates (%) -10-copy testing in ImageNet validation.\nWe find that the mean and minimum values of option B\nthat only uses projections for increasing dimensions.\n\n<table><tr><td>method</td><td>top-1 err.</td><td>top-5</td></tr><tr><td>VGG [40] (ILSVRC'14)</td><td>-</td><td>8.43</td></tr><tr><td>GoogLeNet [43] (ILSVRC'14)</td><td>-</td><td>7.89</td></tr><tr><td>VGG [40] (v5)</td><td>24.4</td><td>7.1</td></tr><tr><td>PReLU-net [12]</td><td>21.59</td><td>5.77</td></tr><tr><td>BN-incoption [16]</td><td>21.99</td><td>5.8</td></tr><tr><td>ResNet-34 B</td><td>21.84</td><td>5.77</td></tr><tr><td>ResNet-34 C</td><td>21.53</td><td>5.66</td></tr><tr><td>ResNet-101</td><td>20.74</td><td>5.2</td></tr><tr><td>ResNet-101</td><td>19.87</td><td>4.66</td></tr><tr><td>ResNet-152</td><td>19.38</td><td>4.48</td></tr></table>\n\nTable 4. Error rates (%) of single-model results on the ImageNet\nvalidation set (except reported on the test set).\n\n<table><tr><td>method</td><td>top-5 err. (test)</td></tr><tr><td>VGG [40] (ILSVRC'14)</td><td>7.32</td></tr><tr><td>GoogLeNet [43] (ILSVRC'14)</td><td>6.66</td></tr><tr><td>VGG [40] (v5)</td><td>6.8</td></tr><tr><td>PReLU-net [12]</td><td>4.94</td></tr><tr><td>BN-inception [16]</td><td>4.82</td></tr><tr><td>ResNet (ILSVRC'15)</td><td>3.57</td></tr></table>\n\nTable 5. Error rates (%) of ensembles . The top-5 error is on the\ntest set of ImageNet and reported by the test server.\n\nResNet reduces the top-1 error by 3.5 % (Table 2 ), resulting\nfrom the successfully reduced training error (Fig. 4 right vs.\nleft). This comparison verifies the effectiveness of residual\nlearning on extremely deep systems.\n\nLast, we also note that the 18-layer plain-residual nets\nare comparably accurate (Table 2 ), but the 18-layer ResNet\nconverges faster (Fig. 4 right vs. left). When the net is \"not\noverly deep\" (18 layers here), the current SGD solver is still\nrelatively insensitive to the plain net. In this case, the\nResNet eases the optimization by providing faster conver-\ngence at the early stage.\n\nIdentity vs. Projection Shortcuts. We have shown that\n\nparameter-free, identity shortcuts help with training. Next\nwe investigate projection shortcuts (Eqn.(2)). In Table 3 we\ncompare three options: (A) zero-padding shortcuts are used\nfor increasing dimensions, and all shortcuts are parameter-\nized; (B) one or two parameterized shortcuts are used for in-\ntion shortcuts are used for increasing dimensions, and other\nshortcuts are identity; and (C) all shortcuts are projections.\n\n[Figure]\n\nFigure 5: A deeper residual function $F$ for ImageNet, Left: self-attention\nblock, Right: “a bottleneck” build-on block for ResNet-50v1 [19]\n\nTable 3 shows that all three options are considerable bet-\nter than the plain counterpart. B is slightly better than A. We\nargue that this is because the zero-padded dimensions in A\nindeed have no residual learning. C is marginally better than\nB, and we attribute this to the extra parameters introduced\nby many (thirteen) projection shortcuts. But the small dif-\nferences among A/B/C indicate that projection shortcuts are\nnot essential for addressing the degradation problem. So we\ndo not use option C in the rest of this paper, to reduce mem-\nory/time complexity and model sizes. Identify shortcuts are\nparticularly important for not increasing the complexity of\nthe bottleneck architectures that are introduced below.\n\nDeeper Bottleneck Architectures. Next we describe our\ndeeper nets for ImageNet. Because of concerns on the train-\ning time that we can afford, we modify the building block\nas a bottleneck design $^4$ . For each residual function $\\mathcal{F}$ , we\nuse a stack of 3 layers instead of 2 (Fig. 5 ). The three layers\nare $1 \\times 1, 3 \\times 3$ , and $1 \\times 1$ convolutions, where the $1 \\times 1$ layers\nare responsible for reducing and then increasing (restoring)\ndimensions, leaving the $3 \\times 3$ layer a bottleneck with smaller\ninput/output dimensions. Fig. 5 shows an example, where\nboth designs have similar time complexity.\n\nThe parameter-free identity shortcuts are particularly im-\nportant for the bottleneck architectures. If the identity short-\ncut in Fig. 5 (right) is replaced with projection, one can\nshow that the time complexity and model size are doubled,\nand the computation time is doubled compared to the two high-dimensional\nends. So identity shortcuts lead to more efficient models\nfor the bottleneck designs.\n\nResNet-50:\n\n$^{*}$Deeper non-bottleneck ResNets (e.g., Fig. 5 left) also gain accuracy\nfrom increased depth (as shown in CIFAR-10), but are not as economical\nas the bottleneck ResNets. So the usage of bottleneck designs is mainly due\nto the breadth and performance limitations of the original implementation\nof plain nets is also witnessed for the bottleneck design.\n\n1",
      "markdown": "<table><tr><td>model</td><td>top-1 err.</td><td>top-5 err.</td></tr><tr><td>VGG-16 [40]</td><td>28.07</td><td>9.33</td></tr><tr><td>GoogleLeNet [43]</td><td>-</td><td>9.15</td></tr><tr><td>PReLU-Net [12]</td><td>24.27</td><td>7.38</td></tr><tr><td>plain-34</td><td>28.54</td><td>10.02</td></tr><tr><td>ResNet-34 A</td><td>25.03</td><td>7.76</td></tr><tr><td>ResNet-34 B</td><td>24.52</td><td>7.46</td></tr><tr><td>ResNet-50</td><td>24.40</td><td>6.92</td></tr><tr><td>ResNet-50</td><td>22.85</td><td>6.71</td></tr><tr><td>ResNet-101</td><td>21.75</td><td>6.05</td></tr><tr><td>ResNet-152</td><td>21.43</td><td>5.71</td></tr></table>\n\n\nTable 3. Error rates (%) -10-copy testing in ImageNet validation. We find that the mean and minimum values of option B that only uses projections for increasing dimensions.\n\n<table><tr><td>method</td><td>top-1 err.</td><td>top-5</td></tr><tr><td>VGG [40] (ILSVRC'14)</td><td>-</td><td>8.43</td></tr><tr><td>GoogLeNet [43] (ILSVRC'14)</td><td>-</td><td>7.89</td></tr><tr><td>VGG [40] (v5)</td><td>24.4</td><td>7.1</td></tr><tr><td>PReLU-net [12]</td><td>21.59</td><td>5.77</td></tr><tr><td>BN-incoption [16]</td><td>21.99</td><td>5.8</td></tr><tr><td>ResNet-34 B</td><td>21.84</td><td>5.77</td></tr><tr><td>ResNet-34 C</td><td>21.53</td><td>5.66</td></tr><tr><td>ResNet-101</td><td>20.74</td><td>5.2</td></tr><tr><td>ResNet-101</td><td>19.87</td><td>4.66</td></tr><tr><td>ResNet-152</td><td>19.38</td><td>4.48</td></tr></table>\n\n\nTable 4. Error rates (%) of single-model results on the ImageNet validation set (except reported on the test set).\n\n<table><tr><td>method</td><td>top-5 err. (test)</td></tr><tr><td>VGG [40] (ILSVRC'14)</td><td>7.32</td></tr><tr><td>GoogLeNet [43] (ILSVRC'14)</td><td>6.66</td></tr><tr><td>VGG [40] (v5)</td><td>6.8</td></tr><tr><td>PReLU-net [12]</td><td>4.94</td></tr><tr><td>BN-inception [16]</td><td>4.82</td></tr><tr><td>ResNet (ILSVRC'15)</td><td>3.57</td></tr></table>\n\n\nTable 5. Error rates (%) of ensembles . The top-5 error is on the test set of ImageNet and reported by the test server.\n\nResNet reduces the top-1 error by 3.5 % (Table 2 ), resulting from the successfully reduced training error (Fig. 4 right vs. left). This comparison verifies the effectiveness of residual learning on extremely deep systems.\n\nLast, we also note that the 18-layer plain-residual nets are comparably accurate (Table 2 ), but the 18-layer ResNet converges faster (Fig. 4 right vs. left). When the net is \"not overly deep\" (18 layers here), the current SGD solver is still relatively insensitive to the plain net. In this case, the ResNet eases the optimization by providing faster convergence at the early stage.\n\nIdentity vs. Projection Shortcuts. We have shown that\n\nparameter-free, identity shortcuts help with training. Next we investigate projection shortcuts (Eqn.(2)). In Table 3 we compare three options: (A) zero-padding shortcuts are used for increasing dimensions, and all shortcuts are parameterized; (B) one or two parameterized shortcuts are used for intion shortcuts are used for increasing dimensions, and other shortcuts are identity; and (C) all shortcuts are projections.\n\n![Figure 10](data:image/png;base64,[Figure])\n\nFigure 5: A deeper residual function $F$ for ImageNet, Left: self-attention block, Right: “a bottleneck” build-on block for ResNet-50v1 [19]\n\nTable 3 shows that all three options are considerable better than the plain counterpart. B is slightly better than A. We argue that this is because the zero-padded dimensions in A indeed have no residual learning. C is marginally better than B, and we attribute this to the extra parameters introduced by many (thirteen) projection shortcuts. But the small differences among A/B/C indicate that projection shortcuts are not essential for addressing the degradation problem. So we do not use option C in the rest of this paper, to reduce memory/time complexity and model sizes. Identify shortcuts are particularly important for not increasing the complexity of the bottleneck architectures that are introduced below.\n\nDeeper Bottleneck Architectures. Next we describe our deeper nets for ImageNet. Because of concerns on the training time that we can afford, we modify the building block as a bottleneck design $^4$ . For each residual function $\\mathcal{F}$ , we use a stack of 3 layers instead of 2 (Fig. 5 ). The three layers are $1 \\times 1, 3 \\times 3$ , and $1 \\times 1$ convolutions, where the $1 \\times 1$ layers are responsible for reducing and then increasing (restoring) dimensions, leaving the $3 \\times 3$ layer a bottleneck with smaller input/output dimensions. Fig. 5 shows an example, where both designs have similar time complexity.\n\nThe parameter-free identity shortcuts are particularly important for the bottleneck architectures. If the identity shortcut in Fig. 5 (right) is replaced with projection, one can show that the time complexity and model size are doubled, and the computation time is doubled compared to the two high-dimensional ends. So identity shortcuts lead to more efficient models for the bottleneck designs.\n\nResNet-50:\n\n$^{*}$Deeper non-bottleneck ResNets (e.g., Fig. 5 left) also gain accuracy from increased depth (as shown in CIFAR-10), but are not as economical as the bottleneck ResNets. So the usage of bottleneck designs is mainly due to the breadth and performance limitations of the original implementation of plain nets is also witnessed for the bottleneck design.\n\n1\n\n"
    },
    {
      "page_number": 7,
      "elements": [
        {
          "type": "paragraph",
          "content": "34-layer net with this 3-layer bottleneck block, resulting in\na 50-layer ResNet (Table 1). We use option B for increasing\ndimensions. This model has 3.8 billion FLOPs.",
          "bbox": [
            54,
            81,
            325,
            123
          ]
        },
        {
          "type": "paragraph",
          "content": "101-layer and 152-layer ResNets: We construct 101-\nlayer and 152-layer ResNets by using more 3-layer blocks\n(Table 1 ). Remarkably, although the depth is significantly\nincreased, the 152-layer ResNet (11.3 billion FLOPs) still\nhas lower complexity than VGG-16/19 nets (15.3/19.6 bil-\nlion FLOPs).",
          "bbox": [
            54,
            123,
            325,
            204
          ]
        },
        {
          "type": "paragraph",
          "content": "The 50/101/152-level ResNets are more accurate than\nthe 34-layer ones by considerable margins (Table 3 and 4 ).\nWe do not observe the degradation problem and thus en-\njoy significant accuracy gains from considerably increased\ndepth. The benefits of depth are witnessed for all evaluation\nmetrics (Table 3 and 4 ).",
          "bbox": [
            54,
            205,
            325,
            287
          ]
        },
        {
          "type": "paragraph",
          "content": "Comparisons with State-of-the-art Methods. In Table 4 ,\nwe compare with the previous best single-model results.\nOur baseline 34-layer ResNets have achieved very compet-\nitive accuracy. Our 152-layer ResNet has a single-model\ntop-5 validation error of 4.49 % . This single-model result\noutperforms all previous ensemble results (Table 5 ). We\ncombine six models of different depth to form an ensemble\n(only with two 152-layer ones at the time of submitting).\nThis leads to 3.57 % top-5 error on the test set (Table 5 ).\nThis entry won the 1st place in ISL/RVC 2015.",
          "bbox": [
            54,
            292,
            325,
            429
          ]
        },
        {
          "type": "subheading",
          "content": "4.2. CIFAR-10 and Analysis",
          "bbox": [
            55,
            438,
            205,
            454
          ]
        },
        {
          "type": "paragraph",
          "content": "We conducted more studies on the CIFAR-10 dataset\n[20] , which consists of 50k training images and 10k test-\ning images in 10 classes. We present experiments trained\non the training set and evaluated on the test set. Our focus\nis on the behaviour of extremely deep networks, but not on\npushing the state-of-the-art results, so we intentionally use\nsimple architectures as follows:",
          "bbox": [
            54,
            460,
            325,
            554
          ]
        },
        {
          "type": "paragraph",
          "content": "The plain/residual architectures follow the foll in Fig. 3\n(middle/right). The network inputs are $32 \\times 32$ images, with\nthe per-pixel mean subtracted. The first layer is $3 \\times 3$ convo-\nlutions. Then we use a stack of $6n$ layers with $3 \\times 3$ convo-\nlutions on the feature maps of $(32 \\times 32)_{i,j}$ respectively,\nwith $2n$ layers for each feature map size. The numbers of\nlayers are chosen such that the weight of the first layer is\nformed by convolution with a stride of 2. The network ends\nwith a global average pooling, a $10\\sqrt{2}$ -fully-connected\nlayer, and softmax. There are totally $6n+2$ stacked weighted\nlayers. The following table summarizes the architecture:",
          "bbox": [
            54,
            555,
            325,
            705
          ]
        },
        {
          "type": "paragraph",
          "content": "so our residual models have exactly the same depth, width,\nand number of parameters as the plain counterparts.",
          "bbox": [
            346,
            343,
            617,
            370
          ]
        },
        {
          "type": "table",
          "content": "<table><tr><td>output map size</td><td>32×32</td><td>16×16</td><td>8×8</td></tr><tr><td># layers</td><td>1+2n</td><td>2n</td><td>2n</td></tr><tr><td># filters</td><td>16</td><td>32</td><td>64</td></tr></table>",
          "bbox": [
            89,
            715,
            292,
            757
          ]
        },
        {
          "type": "paragraph",
          "content": "When shortcut connections are used, they are connected\nto the pairs of 3×3 layers (totally 3n shortcuts). On this\ndataset we use identity shortcuts in all cases (i.e., option A),",
          "bbox": [
            54,
            766,
            325,
            808
          ]
        },
        {
          "type": "table",
          "content": "<table><tr><td></td><td colspan=\"2\">method</td><td>error (%)</td></tr><tr><td></td><td rowspan=\"3\">Maxout [9] NIN [25] DSN [24]</td><td rowspan=\"3\"></td><td>9.38</td></tr><tr><td></td><td>8.81</td></tr><tr><td></td><td>8.22</td></tr><tr><td></td><td># layers</td><td># params</td><td></td></tr><tr><td>FitNet [34]</td><td>19</td><td>2.5M</td><td>8.39</td></tr><tr><td>Highway [41, 42]</td><td>19</td><td>2.3M</td><td>7.54 (7.72±0.16)</td></tr><tr><td>Highway [41, 42]</td><td>32</td><td>1.25M</td><td>8.80</td></tr><tr><td>ResNet</td><td>20</td><td>0.27M</td><td>8.75</td></tr><tr><td>ResNet</td><td>32</td><td>0.46M</td><td>7.51</td></tr><tr><td>ResNet</td><td>44</td><td>0.66M</td><td>7.17</td></tr><tr><td>ResNet</td><td>56</td><td>0.85M</td><td>6.97</td></tr><tr><td>ResNet</td><td>110</td><td>1.7M</td><td>6.43 (6.61±0.16)</td></tr><tr><td>ResNet</td><td>1202</td><td>19.4M</td><td>7.93</td></tr></table>",
          "bbox": [
            349,
            82,
            613,
            273
          ]
        },
        {
          "type": "paragraph",
          "content": "Table 6. Classification error on the CIFAR-10 set. All meth-\nods are chosen as [2] . The results are averaged. $\\bar{x}$ means\nand show “ best mean±std ” as in [42] .",
          "bbox": [
            346,
            283,
            617,
            323
          ]
        },
        {
          "type": "paragraph",
          "content": "We use a weight decay of 0.0001 and momentum of 0.9,\nand adopt the weight initialization in [12] and BN [16] but\nwith no dropout. These models are trained with a mini-\nbatch size of 128 on two GPUs. We start with a learning\nrate of 0.1, divide it by 10 at 32x and 48x iterations, and\nterminate training at 64k iterations, which is determined on\na 256×256 visual split. During the data augmentation\noperation [24] , we randomly sample a fixed number of\na and a 32×32 crop is randomly sampled from the padded\nimage or its horizontal flip. For testing, we only evaluate\nthe single view of the original 32×32 image.",
          "bbox": [
            346,
            371,
            618,
            519
          ]
        },
        {
          "type": "paragraph",
          "content": "We compare $\\pi=\\{3,5,7,9\\}$ , leading to 20, 32, 44, and\n56-layer networks. Fig. 6 (left) shows the behaviour of the\nplain nets. The deep plain nets suffer from increased depth,\nand exhibit higher training error when going deeper. This\nis because the models are deeper than these plain nets and\non MNIST (see [41] ), so that on ImageNet (fig. 4 , left) and\non MNIST (see [41] ), it is hard that such an optimization\ndifficulty is a fundamental problem.",
          "bbox": [
            346,
            519,
            618,
            614
          ]
        },
        {
          "type": "paragraph",
          "content": "Fig. 6 (middle) shows the behaviors of ResNets. Also,\nsimilar to the ImageNet cases (Fig. 4 , right), our ResNets\nmanage to overcome the optimization difficulty and demon-\nstrate accuracy gains when the depth increases.",
          "bbox": [
            346,
            614,
            617,
            668
          ]
        },
        {
          "type": "paragraph",
          "content": "We further explore $n=18$ that leads to a 110-layer\nResNet. In this case, we find that the initial learning rate\nof 0.1 is slightly too large to start converging. $^3$ So we use\n0.01 to warm up the training until the training error is below\n80 % (about 400 iterations), and then go back to 0.1 and con-\ntinue training. The rest of the learning schedule is as done\npreviously. This 110-layer network converges well (Fig. 6 ,\nmiddle). It has fewer parameters than other deep and thin",
          "bbox": [
            346,
            668,
            618,
            777
          ]
        },
        {
          "type": "footnote",
          "content": "With an initial learning rate of 0.1, it starts converging (<90% error)\nafter several epochs, but still reaches similar accuracy.",
          "bbox": [
            347,
            784,
            617,
            808
          ]
        },
        {
          "type": "paragraph",
          "content": "776",
          "bbox": [
            337,
            829,
            354,
            841
          ]
        }
      ],
      "text": "34-layer net with this 3-layer bottleneck block, resulting in\na 50-layer ResNet (Table 1). We use option B for increasing\ndimensions. This model has 3.8 billion FLOPs.\n\n101-layer and 152-layer ResNets: We construct 101-\nlayer and 152-layer ResNets by using more 3-layer blocks\n(Table 1 ). Remarkably, although the depth is significantly\nincreased, the 152-layer ResNet (11.3 billion FLOPs) still\nhas lower complexity than VGG-16/19 nets (15.3/19.6 bil-\nlion FLOPs).\n\nThe 50/101/152-level ResNets are more accurate than\nthe 34-layer ones by considerable margins (Table 3 and 4 ).\nWe do not observe the degradation problem and thus en-\njoy significant accuracy gains from considerably increased\ndepth. The benefits of depth are witnessed for all evaluation\nmetrics (Table 3 and 4 ).\n\nComparisons with State-of-the-art Methods. In Table 4 ,\nwe compare with the previous best single-model results.\nOur baseline 34-layer ResNets have achieved very compet-\nitive accuracy. Our 152-layer ResNet has a single-model\ntop-5 validation error of 4.49 % . This single-model result\noutperforms all previous ensemble results (Table 5 ). We\ncombine six models of different depth to form an ensemble\n(only with two 152-layer ones at the time of submitting).\nThis leads to 3.57 % top-5 error on the test set (Table 5 ).\nThis entry won the 1st place in ISL/RVC 2015.\n\n4.2. CIFAR-10 and Analysis\n\nWe conducted more studies on the CIFAR-10 dataset\n[20] , which consists of 50k training images and 10k test-\ning images in 10 classes. We present experiments trained\non the training set and evaluated on the test set. Our focus\nis on the behaviour of extremely deep networks, but not on\npushing the state-of-the-art results, so we intentionally use\nsimple architectures as follows:\n\nThe plain/residual architectures follow the foll in Fig. 3\n(middle/right). The network inputs are $32 \\times 32$ images, with\nthe per-pixel mean subtracted. The first layer is $3 \\times 3$ convo-\nlutions. Then we use a stack of $6n$ layers with $3 \\times 3$ convo-\nlutions on the feature maps of $(32 \\times 32)_{i,j}$ respectively,\nwith $2n$ layers for each feature map size. The numbers of\nlayers are chosen such that the weight of the first layer is\nformed by convolution with a stride of 2. The network ends\nwith a global average pooling, a $10\\sqrt{2}$ -fully-connected\nlayer, and softmax. There are totally $6n+2$ stacked weighted\nlayers. The following table summarizes the architecture:\n\nso our residual models have exactly the same depth, width,\nand number of parameters as the plain counterparts.\n\n<table><tr><td>output map size</td><td>32×32</td><td>16×16</td><td>8×8</td></tr><tr><td># layers</td><td>1+2n</td><td>2n</td><td>2n</td></tr><tr><td># filters</td><td>16</td><td>32</td><td>64</td></tr></table>\n\nWhen shortcut connections are used, they are connected\nto the pairs of 3×3 layers (totally 3n shortcuts). On this\ndataset we use identity shortcuts in all cases (i.e., option A),\n\n<table><tr><td></td><td colspan=\"2\">method</td><td>error (%)</td></tr><tr><td></td><td rowspan=\"3\">Maxout [9] NIN [25] DSN [24]</td><td rowspan=\"3\"></td><td>9.38</td></tr><tr><td></td><td>8.81</td></tr><tr><td></td><td>8.22</td></tr><tr><td></td><td># layers</td><td># params</td><td></td></tr><tr><td>FitNet [34]</td><td>19</td><td>2.5M</td><td>8.39</td></tr><tr><td>Highway [41, 42]</td><td>19</td><td>2.3M</td><td>7.54 (7.72±0.16)</td></tr><tr><td>Highway [41, 42]</td><td>32</td><td>1.25M</td><td>8.80</td></tr><tr><td>ResNet</td><td>20</td><td>0.27M</td><td>8.75</td></tr><tr><td>ResNet</td><td>32</td><td>0.46M</td><td>7.51</td></tr><tr><td>ResNet</td><td>44</td><td>0.66M</td><td>7.17</td></tr><tr><td>ResNet</td><td>56</td><td>0.85M</td><td>6.97</td></tr><tr><td>ResNet</td><td>110</td><td>1.7M</td><td>6.43 (6.61±0.16)</td></tr><tr><td>ResNet</td><td>1202</td><td>19.4M</td><td>7.93</td></tr></table>\n\nTable 6. Classification error on the CIFAR-10 set. All meth-\nods are chosen as [2] . The results are averaged. $\\bar{x}$ means\nand show “ best mean±std ” as in [42] .\n\nWe use a weight decay of 0.0001 and momentum of 0.9,\nand adopt the weight initialization in [12] and BN [16] but\nwith no dropout. These models are trained with a mini-\nbatch size of 128 on two GPUs. We start with a learning\nrate of 0.1, divide it by 10 at 32x and 48x iterations, and\nterminate training at 64k iterations, which is determined on\na 256×256 visual split. During the data augmentation\noperation [24] , we randomly sample a fixed number of\na and a 32×32 crop is randomly sampled from the padded\nimage or its horizontal flip. For testing, we only evaluate\nthe single view of the original 32×32 image.\n\nWe compare $\\pi=\\{3,5,7,9\\}$ , leading to 20, 32, 44, and\n56-layer networks. Fig. 6 (left) shows the behaviour of the\nplain nets. The deep plain nets suffer from increased depth,\nand exhibit higher training error when going deeper. This\nis because the models are deeper than these plain nets and\non MNIST (see [41] ), so that on ImageNet (fig. 4 , left) and\non MNIST (see [41] ), it is hard that such an optimization\ndifficulty is a fundamental problem.\n\nFig. 6 (middle) shows the behaviors of ResNets. Also,\nsimilar to the ImageNet cases (Fig. 4 , right), our ResNets\nmanage to overcome the optimization difficulty and demon-\nstrate accuracy gains when the depth increases.\n\nWe further explore $n=18$ that leads to a 110-layer\nResNet. In this case, we find that the initial learning rate\nof 0.1 is slightly too large to start converging. $^3$ So we use\n0.01 to warm up the training until the training error is below\n80 % (about 400 iterations), and then go back to 0.1 and con-\ntinue training. The rest of the learning schedule is as done\npreviously. This 110-layer network converges well (Fig. 6 ,\nmiddle). It has fewer parameters than other deep and thin\n\nWith an initial learning rate of 0.1, it starts converging (<90% error)\nafter several epochs, but still reaches similar accuracy.\n\n776",
      "markdown": "34-layer net with this 3-layer bottleneck block, resulting in a 50-layer ResNet (Table 1). We use option B for increasing dimensions. This model has 3.8 billion FLOPs.\n\n101-layer and 152-layer ResNets: We construct 101layer and 152-layer ResNets by using more 3-layer blocks (Table 1 ). Remarkably, although the depth is significantly increased, the 152-layer ResNet (11.3 billion FLOPs) still has lower complexity than VGG-16/19 nets (15.3/19.6 billion FLOPs).\n\nThe 50/101/152-level ResNets are more accurate than the 34-layer ones by considerable margins (Table 3 and 4 ). We do not observe the degradation problem and thus enjoy significant accuracy gains from considerably increased depth. The benefits of depth are witnessed for all evaluation metrics (Table 3 and 4 ).\n\nComparisons with State-of-the-art Methods. In Table 4 , we compare with the previous best single-model results. Our baseline 34-layer ResNets have achieved very competitive accuracy. Our 152-layer ResNet has a single-model top-5 validation error of 4.49 % . This single-model result outperforms all previous ensemble results (Table 5 ). We combine six models of different depth to form an ensemble (only with two 152-layer ones at the time of submitting). This leads to 3.57 % top-5 error on the test set (Table 5 ). This entry won the 1st place in ISL/RVC 2015.\n\n### 4.2. CIFAR-10 and Analysis\n\nWe conducted more studies on the CIFAR-10 dataset [20] , which consists of 50k training images and 10k testing images in 10 classes. We present experiments trained on the training set and evaluated on the test set. Our focus is on the behaviour of extremely deep networks, but not on pushing the state-of-the-art results, so we intentionally use simple architectures as follows:\n\nThe plain/residual architectures follow the foll in Fig. 3 (middle/right). The network inputs are $32 \\times 32$ images, with the per-pixel mean subtracted. The first layer is $3 \\times 3$ convolutions. Then we use a stack of $6n$ layers with $3 \\times 3$ convolutions on the feature maps of $(32 \\times 32)_{i,j}$ respectively, with $2n$ layers for each feature map size. The numbers of layers are chosen such that the weight of the first layer is formed by convolution with a stride of 2. The network ends with a global average pooling, a $10\\sqrt{2}$ -fully-connected layer, and softmax. There are totally $6n+2$ stacked weighted layers. The following table summarizes the architecture:\n\nso our residual models have exactly the same depth, width, and number of parameters as the plain counterparts.\n\n<table><tr><td>output map size</td><td>32×32</td><td>16×16</td><td>8×8</td></tr><tr><td># layers</td><td>1+2n</td><td>2n</td><td>2n</td></tr><tr><td># filters</td><td>16</td><td>32</td><td>64</td></tr></table>\n\n\nWhen shortcut connections are used, they are connected to the pairs of 3×3 layers (totally 3n shortcuts). On this dataset we use identity shortcuts in all cases (i.e., option A),\n\n<table><tr><td></td><td colspan=\"2\">method</td><td>error (%)</td></tr><tr><td></td><td rowspan=\"3\">Maxout [9] NIN [25] DSN [24]</td><td rowspan=\"3\"></td><td>9.38</td></tr><tr><td></td><td>8.81</td></tr><tr><td></td><td>8.22</td></tr><tr><td></td><td># layers</td><td># params</td><td></td></tr><tr><td>FitNet [34]</td><td>19</td><td>2.5M</td><td>8.39</td></tr><tr><td>Highway [41, 42]</td><td>19</td><td>2.3M</td><td>7.54 (7.72±0.16)</td></tr><tr><td>Highway [41, 42]</td><td>32</td><td>1.25M</td><td>8.80</td></tr><tr><td>ResNet</td><td>20</td><td>0.27M</td><td>8.75</td></tr><tr><td>ResNet</td><td>32</td><td>0.46M</td><td>7.51</td></tr><tr><td>ResNet</td><td>44</td><td>0.66M</td><td>7.17</td></tr><tr><td>ResNet</td><td>56</td><td>0.85M</td><td>6.97</td></tr><tr><td>ResNet</td><td>110</td><td>1.7M</td><td>6.43 (6.61±0.16)</td></tr><tr><td>ResNet</td><td>1202</td><td>19.4M</td><td>7.93</td></tr></table>\n\n\nTable 6. Classification error on the CIFAR-10 set. All methods are chosen as [2] . The results are averaged. $\\bar{x}$ means and show “ best mean±std ” as in [42] .\n\nWe use a weight decay of 0.0001 and momentum of 0.9, and adopt the weight initialization in [12] and BN [16] but with no dropout. These models are trained with a minibatch size of 128 on two GPUs. We start with a learning rate of 0.1, divide it by 10 at 32x and 48x iterations, and terminate training at 64k iterations, which is determined on a 256×256 visual split. During the data augmentation operation [24] , we randomly sample a fixed number of a and a 32×32 crop is randomly sampled from the padded image or its horizontal flip. For testing, we only evaluate the single view of the original 32×32 image.\n\nWe compare $\\pi=\\{3,5,7,9\\}$ , leading to 20, 32, 44, and 56-layer networks. Fig. 6 (left) shows the behaviour of the plain nets. The deep plain nets suffer from increased depth, and exhibit higher training error when going deeper. This is because the models are deeper than these plain nets and on MNIST (see [41] ), so that on ImageNet (fig. 4 , left) and on MNIST (see [41] ), it is hard that such an optimization difficulty is a fundamental problem.\n\nFig. 6 (middle) shows the behaviors of ResNets. Also, similar to the ImageNet cases (Fig. 4 , right), our ResNets manage to overcome the optimization difficulty and demonstrate accuracy gains when the depth increases.\n\nWe further explore $n=18$ that leads to a 110-layer ResNet. In this case, we find that the initial learning rate of 0.1 is slightly too large to start converging. $^3$ So we use 0.01 to warm up the training until the training error is below 80 % (about 400 iterations), and then go back to 0.1 and continue training. The rest of the learning schedule is as done previously. This 110-layer network converges well (Fig. 6 , middle). It has fewer parameters than other deep and thin\n\nWith an initial learning rate of 0.1, it starts converging (<90% error) after several epochs, but still reaches similar accuracy.\n\n776\n\n"
    },
    {
      "page_number": 8,
      "elements": [
        {
          "type": "figure",
          "content": "[Figure]",
          "bbox": [
            111,
            80,
            562,
            194
          ]
        },
        {
          "type": "paragraph",
          "content": "Figure 6. Training on CIFAR-10 . Dashed lines denote training error, and bold lines denote testing error. Left : plain networks. The error\nof plain-110 is higher than 60 % and not displayed. Middle : ResNets. Right : ResNets with 110 and 1202 layers.",
          "bbox": [
            53,
            194,
            618,
            220
          ]
        },
        {
          "type": "figure",
          "content": "[Figure]",
          "bbox": [
            68,
            240,
            297,
            370
          ]
        },
        {
          "type": "paragraph",
          "content": "Figure 7. Standard deviations (std) of layer responses on CIFAR-10.\nThe responses are the outputs of each $3 \\times 3$ layer, after BN and\nbefore nonlinearity. Top: the layers are shown in their original\norder. Bottom: the responses are ranked in descending order.",
          "bbox": [
            53,
            369,
            325,
            420
          ]
        },
        {
          "type": "paragraph",
          "content": "networks such as FitNet [34] and Highway [41] (Table 6 ),\n yet is among the state-of-the-art results (6.43%, Table 6 ).",
          "bbox": [
            54,
            440,
            325,
            470
          ]
        },
        {
          "type": "paragraph",
          "content": "Analysis of Layer Responses. Fig. 7 shows the standard\ndeviations (std) of the layer responses. The responses are\nthe outputs of each 3 $\\times$ 3 layer, after BN and before other\nnonlinearity (ReLU/Addition). For ResNets, this analy-\nsis reveals the response strength of the residual functions.\nFig. 7 shows that ResNets have generally smaller responses\nthan their plain counterparts. These results support our ba-\nsic motivation (Sec. 3.1 ) that the residual functions might\nbe generally closer to zero than the non-residual functions.\nWe also notice that the deeper ResNet has smaller magni-\ntudes of responses, as evidenced by the comparisons among\nResNet-20, 56, and 110 in Fig. 7 . When there are more\nlayers, an individual layer of ResNets tends to modify the\nsignal less.",
          "bbox": [
            53,
            475,
            326,
            666
          ]
        },
        {
          "type": "paragraph",
          "content": "Exploring Over 1000 layers. We explore an aggressively\ndeep model of over 1000 layers. We set $n=200$ that\nleads to a 1202-layer network, which is trained as described\nabove. Our method shows no optimization difficulty , and\nour 10-layer network is able to achieve training error\n$<$ 0.1 % (Fig. 7 ). Their result is still fairly good\n(7.93 % ; Table 6 ).",
          "bbox": [
            53,
            672,
            326,
            767
          ]
        },
        {
          "type": "paragraph",
          "content": "But there are still open problems on such aggregately\ndescribed models that quantify the performance of neural\nnetworks. For instance, the aggregation of inputs into one\nis worse than that of our 10-layer network, although both",
          "bbox": [
            53,
            766,
            326,
            807
          ]
        },
        {
          "type": "paragraph",
          "content": "have similar training error. We argue that this is because of\noverfitting. The 1202-layer network may be unnecessarily\nlarge (19.4M) for this small dataset. Strong regularization\nsuch as maxout/dropout [13] is applied to obtain the\nbest results (9, 28, 24, 34) on this dataset. In this paper, we\nuse no maxout/dropout and just simply impose regulariza-\ntion via deep and thin architectures by design, without dis-\ntracting from the focus on the difficulties of optimization.\nBut combining with stronger regularization may improve\nresults, which we will study in the future.",
          "bbox": [
            347,
            425,
            619,
            563
          ]
        },
        {
          "type": "table",
          "content": "<table><tr><td>training data</td><td>07+12</td><td>07+12</td></tr><tr><td>test data</td><td>VOC 07 test</td><td>VOC 12 test</td></tr><tr><td>VGG-16</td><td>73.2</td><td>70.4</td></tr><tr><td>ResNet-101</td><td>76.4</td><td>73.8</td></tr></table>",
          "bbox": [
            379,
            241,
            586,
            294
          ]
        },
        {
          "type": "paragraph",
          "content": "Table 7: Object detection mAP (%) on the PASCAL VOC\ntraining set against baseline Faster R-CNN. See also ap-\npendix for results details.",
          "bbox": [
            347,
            297,
            618,
            336
          ]
        },
        {
          "type": "table",
          "content": "<table><tr><td>metric</td><td>mAP@0.5 (↑)</td><td>mAP@{0.5, .95} (↑)</td></tr><tr><td>Faster R-CNN</td><td>33.7</td><td>29.1</td></tr><tr><td>R-Net-101</td><td>48.4</td><td>27.2</td></tr></table>",
          "bbox": [
            383,
            341,
            579,
            381
          ]
        },
        {
          "type": "paragraph",
          "content": "Table 8. Object detection mAP (%) on the COCO validation set\nusing baseline Faster RCNN. See also appendix for better results.",
          "bbox": [
            347,
            385,
            618,
            411
          ]
        },
        {
          "type": "subheading",
          "content": "4.3. Object Detection on PASCAL and MS COCO",
          "bbox": [
            347,
            569,
            613,
            586
          ]
        },
        {
          "type": "paragraph",
          "content": "Our method has good generalization performance on\nother recognition tasks. Table 7 and 8 show the object de-\ntection baseline results on PASCAL VOC 2007 and 2012\n[5] and COCO [26] . We adopt Faster R-CNN [32] as the de-\ntection method. Here we are interested in the improvements\nof replacing VGG-16 [40] with ResNet-101. The detection\nimplementation (see appendix) of using both models is the\nsame, so the gains can only be attributed to better networks.\nMost remarkably, on the challenging COCO dataset we ob-\ntain a 6.0 % increase in COCO's standard metric (mAP@[.5,\n.95]), which is a 28 % relative improvement. This gain is\nsolely due to the learned representations.",
          "bbox": [
            347,
            590,
            619,
            754
          ]
        },
        {
          "type": "paragraph",
          "content": "Based on deep residual nets, we won the 1st places in\nseveral tracks in ISLRC & COCO 2015 competitions: Im-\nageNet detection, ImageNet localization, COCO detection,\nand COCO segmentation. The details are in the appendix.",
          "bbox": [
            347,
            754,
            618,
            807
          ]
        },
        {
          "type": "paragraph",
          "content": "1",
          "bbox": [
            336,
            859,
            354,
            872
          ]
        }
      ],
      "text": "[Figure]\n\nFigure 6. Training on CIFAR-10 . Dashed lines denote training error, and bold lines denote testing error. Left : plain networks. The error\nof plain-110 is higher than 60 % and not displayed. Middle : ResNets. Right : ResNets with 110 and 1202 layers.\n\n[Figure]\n\nFigure 7. Standard deviations (std) of layer responses on CIFAR-10.\nThe responses are the outputs of each $3 \\times 3$ layer, after BN and\nbefore nonlinearity. Top: the layers are shown in their original\norder. Bottom: the responses are ranked in descending order.\n\nnetworks such as FitNet [34] and Highway [41] (Table 6 ),\n yet is among the state-of-the-art results (6.43%, Table 6 ).\n\nAnalysis of Layer Responses. Fig. 7 shows the standard\ndeviations (std) of the layer responses. The responses are\nthe outputs of each 3 $\\times$ 3 layer, after BN and before other\nnonlinearity (ReLU/Addition). For ResNets, this analy-\nsis reveals the response strength of the residual functions.\nFig. 7 shows that ResNets have generally smaller responses\nthan their plain counterparts. These results support our ba-\nsic motivation (Sec. 3.1 ) that the residual functions might\nbe generally closer to zero than the non-residual functions.\nWe also notice that the deeper ResNet has smaller magni-\ntudes of responses, as evidenced by the comparisons among\nResNet-20, 56, and 110 in Fig. 7 . When there are more\nlayers, an individual layer of ResNets tends to modify the\nsignal less.\n\nExploring Over 1000 layers. We explore an aggressively\ndeep model of over 1000 layers. We set $n=200$ that\nleads to a 1202-layer network, which is trained as described\nabove. Our method shows no optimization difficulty , and\nour 10-layer network is able to achieve training error\n$<$ 0.1 % (Fig. 7 ). Their result is still fairly good\n(7.93 % ; Table 6 ).\n\nBut there are still open problems on such aggregately\ndescribed models that quantify the performance of neural\nnetworks. For instance, the aggregation of inputs into one\nis worse than that of our 10-layer network, although both\n\nhave similar training error. We argue that this is because of\noverfitting. The 1202-layer network may be unnecessarily\nlarge (19.4M) for this small dataset. Strong regularization\nsuch as maxout/dropout [13] is applied to obtain the\nbest results (9, 28, 24, 34) on this dataset. In this paper, we\nuse no maxout/dropout and just simply impose regulariza-\ntion via deep and thin architectures by design, without dis-\ntracting from the focus on the difficulties of optimization.\nBut combining with stronger regularization may improve\nresults, which we will study in the future.\n\n<table><tr><td>training data</td><td>07+12</td><td>07+12</td></tr><tr><td>test data</td><td>VOC 07 test</td><td>VOC 12 test</td></tr><tr><td>VGG-16</td><td>73.2</td><td>70.4</td></tr><tr><td>ResNet-101</td><td>76.4</td><td>73.8</td></tr></table>\n\nTable 7: Object detection mAP (%) on the PASCAL VOC\ntraining set against baseline Faster R-CNN. See also ap-\npendix for results details.\n\n<table><tr><td>metric</td><td>mAP@0.5 (↑)</td><td>mAP@{0.5, .95} (↑)</td></tr><tr><td>Faster R-CNN</td><td>33.7</td><td>29.1</td></tr><tr><td>R-Net-101</td><td>48.4</td><td>27.2</td></tr></table>\n\nTable 8. Object detection mAP (%) on the COCO validation set\nusing baseline Faster RCNN. See also appendix for better results.\n\n4.3. Object Detection on PASCAL and MS COCO\n\nOur method has good generalization performance on\nother recognition tasks. Table 7 and 8 show the object de-\ntection baseline results on PASCAL VOC 2007 and 2012\n[5] and COCO [26] . We adopt Faster R-CNN [32] as the de-\ntection method. Here we are interested in the improvements\nof replacing VGG-16 [40] with ResNet-101. The detection\nimplementation (see appendix) of using both models is the\nsame, so the gains can only be attributed to better networks.\nMost remarkably, on the challenging COCO dataset we ob-\ntain a 6.0 % increase in COCO's standard metric (mAP@[.5,\n.95]), which is a 28 % relative improvement. This gain is\nsolely due to the learned representations.\n\nBased on deep residual nets, we won the 1st places in\nseveral tracks in ISLRC & COCO 2015 competitions: Im-\nageNet detection, ImageNet localization, COCO detection,\nand COCO segmentation. The details are in the appendix.\n\n1",
      "markdown": "![Figure 0](data:image/png;base64,[Figure])\n\nFigure 6. Training on CIFAR-10 . Dashed lines denote training error, and bold lines denote testing error. Left : plain networks. The error of plain-110 is higher than 60 % and not displayed. Middle : ResNets. Right : ResNets with 110 and 1202 layers.\n\n![Figure 2](data:image/png;base64,[Figure])\n\nFigure 7. Standard deviations (std) of layer responses on CIFAR-10. The responses are the outputs of each $3 \\times 3$ layer, after BN and before nonlinearity. Top: the layers are shown in their original order. Bottom: the responses are ranked in descending order.\n\nnetworks such as FitNet [34] and Highway [41] (Table 6 ), yet is among the state-of-the-art results (6.43%, Table 6 ).\n\nAnalysis of Layer Responses. Fig. 7 shows the standard deviations (std) of the layer responses. The responses are the outputs of each 3 $\\times$ 3 layer, after BN and before other nonlinearity (ReLU/Addition). For ResNets, this analysis reveals the response strength of the residual functions. Fig. 7 shows that ResNets have generally smaller responses than their plain counterparts. These results support our basic motivation (Sec. 3.1 ) that the residual functions might be generally closer to zero than the non-residual functions. We also notice that the deeper ResNet has smaller magnitudes of responses, as evidenced by the comparisons among ResNet-20, 56, and 110 in Fig. 7 . When there are more layers, an individual layer of ResNets tends to modify the signal less.\n\nExploring Over 1000 layers. We explore an aggressively deep model of over 1000 layers. We set $n=200$ that leads to a 1202-layer network, which is trained as described above. Our method shows no optimization difficulty , and our 10-layer network is able to achieve training error $<$ 0.1 % (Fig. 7 ). Their result is still fairly good (7.93 % ; Table 6 ).\n\nBut there are still open problems on such aggregately described models that quantify the performance of neural networks. For instance, the aggregation of inputs into one is worse than that of our 10-layer network, although both\n\nhave similar training error. We argue that this is because of overfitting. The 1202-layer network may be unnecessarily large (19.4M) for this small dataset. Strong regularization such as maxout/dropout [13] is applied to obtain the best results (9, 28, 24, 34) on this dataset. In this paper, we use no maxout/dropout and just simply impose regularization via deep and thin architectures by design, without distracting from the focus on the difficulties of optimization. But combining with stronger regularization may improve results, which we will study in the future.\n\n<table><tr><td>training data</td><td>07+12</td><td>07+12</td></tr><tr><td>test data</td><td>VOC 07 test</td><td>VOC 12 test</td></tr><tr><td>VGG-16</td><td>73.2</td><td>70.4</td></tr><tr><td>ResNet-101</td><td>76.4</td><td>73.8</td></tr></table>\n\n\nTable 7: Object detection mAP (%) on the PASCAL VOC training set against baseline Faster R-CNN. See also appendix for results details.\n\n<table><tr><td>metric</td><td>mAP@0.5 (↑)</td><td>mAP@{0.5, .95} (↑)</td></tr><tr><td>Faster R-CNN</td><td>33.7</td><td>29.1</td></tr><tr><td>R-Net-101</td><td>48.4</td><td>27.2</td></tr></table>\n\n\nTable 8. Object detection mAP (%) on the COCO validation set using baseline Faster RCNN. See also appendix for better results.\n\n### 4.3. Object Detection on PASCAL and MS COCO\n\nOur method has good generalization performance on other recognition tasks. Table 7 and 8 show the object detection baseline results on PASCAL VOC 2007 and 2012 [5] and COCO [26] . We adopt Faster R-CNN [32] as the detection method. Here we are interested in the improvements of replacing VGG-16 [40] with ResNet-101. The detection implementation (see appendix) of using both models is the same, so the gains can only be attributed to better networks. Most remarkably, on the challenging COCO dataset we obtain a 6.0 % increase in COCO's standard metric (mAP@[.5, .95]), which is a 28 % relative improvement. This gain is solely due to the learned representations.\n\nBased on deep residual nets, we won the 1st places in several tracks in ISLRC & COCO 2015 competitions: ImageNet detection, ImageNet localization, COCO detection, and COCO segmentation. The details are in the appendix.\n\n1\n\n"
    },
    {
      "page_number": 9,
      "elements": [
        {
          "type": "heading",
          "content": "References",
          "bbox": [
            55,
            81,
            118,
            97
          ]
        },
        {
          "type": "paragraph",
          "content": "Y. Bengio, P. Simard and P. Frasconi . Learning long-term dependents\non past experiences. In Proc. IEEE Transactions on Information\nNetworks , 5(2):157–166, 1994.",
          "bbox": [
            60,
            103,
            323,
            136
          ]
        },
        {
          "type": "paragraph",
          "content": "[2] C. M. Bishop, Neural networks for pattern recognition . Oxford\nUniversity press, 1995.",
          "bbox": [
            60,
            137,
            323,
            160
          ]
        },
        {
          "type": "paragraph",
          "content": "[3] W. L. Briggs, S. F. McCormick, et al. A Multigrid Tutorial . Siam,\n2000.",
          "bbox": [
            60,
            160,
            323,
            181
          ]
        },
        {
          "type": "paragraph",
          "content": "[6] K. Chaffatil, V. Lemovsky, A. Vedraldi, and A. Zisserman. The deviance\nof language: an evaluation of recent feature encoding methods.\nIn BMVC , 2011.",
          "bbox": [
            60,
            183,
            323,
            215
          ]
        },
        {
          "type": "paragraph",
          "content": "[1] M. Everingham, L. Van Gool, K. E. Williams, J. Winn, and J. M. Swinski, \"Computer vision\nevaluation through borderline detection of objects (VOC) challenge\", IGCV,\npages 303–338, 2010.",
          "bbox": [
            60,
            216,
            323,
            248
          ]
        },
        {
          "type": "paragraph",
          "content": "[6] R. Girshick. Fast R-CNN. In ICCV , 2015.",
          "bbox": [
            60,
            250,
            231,
            260
          ]
        },
        {
          "type": "paragraph",
          "content": "19. R. Girshick, J. Donahue, T. Darrell, and J. Malik. Risk reduction for\nconvex object detection and segmentation. In\nCVPR , 2014.",
          "bbox": [
            60,
            261,
            324,
            292
          ]
        },
        {
          "type": "paragraph",
          "content": "[8] X. Glorot and Y. Bengio. Understanding the difficulty of training\ndeep feedforward neural networks. In AISTATS , 2010.",
          "bbox": [
            60,
            293,
            324,
            314
          ]
        },
        {
          "type": "paragraph",
          "content": "[9] I. J. Goodfellow, D. Warde-Farley, M. Mirza, A. Courville, and\nY. Bengio, Maxout networks. arXiv:1302.4389 , 2013.",
          "bbox": [
            60,
            316,
            323,
            337
          ]
        },
        {
          "type": "paragraph",
          "content": "10 K. He and J. Sun. Convolutional neural networks at constrained time\ncost. In CVPR , 2015.",
          "bbox": [
            60,
            338,
            323,
            360
          ]
        },
        {
          "type": "paragraph",
          "content": "#1 K. He, X. Zhang, S. Ren, and J. Sun. Spatial pyramid pooling in deep\nconvolutional networks for visual recognition. In ECCV , 2014.",
          "bbox": [
            60,
            361,
            323,
            382
          ]
        },
        {
          "type": "paragraph",
          "content": "6. Ke, H., X. Zhang, R. Ren, and J. Sun. Delving deep into rectifier\ngains: Human-level performance on imagenet classification. In\nICCT , 2017.",
          "bbox": [
            60,
            383,
            323,
            415
          ]
        },
        {
          "type": "paragraph",
          "content": "[3] G. E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, et al.\nDeep residual learning for convolutional neural networks, in: Proceedings of\nadaption to feature detectors, pp. 127-158(2012).",
          "bbox": [
            60,
            416,
            323,
            449
          ]
        },
        {
          "type": "paragraph",
          "content": "[4] S. Hochreiter, Untersuchungen zu dynamischen neuronalen netzen,\nDiploma thesis , TU Munich, 1991.",
          "bbox": [
            60,
            450,
            322,
            471
          ]
        },
        {
          "type": "paragraph",
          "content": "[15] S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural\ncomputation , 9(8):1735–1780, 1997.",
          "bbox": [
            60,
            472,
            324,
            494
          ]
        },
        {
          "type": "paragraph",
          "content": "[16] S. Ioffi and C. Szegedy. Batch normalization: Accelerating deep\nnetwork training by reducing internal covariate shift. In ICML , 2015.",
          "bbox": [
            60,
            495,
            324,
            516
          ]
        },
        {
          "type": "paragraph",
          "content": "[17] H. Jegou, M. Douze, and C. Schmid. Product quantization for nearest\nneighbor search. TPAMI , 33, 2011.",
          "bbox": [
            60,
            517,
            324,
            538
          ]
        },
        {
          "type": "paragraph",
          "content": "[1] H. Jegou, F. Perronnin, M. Douze, J. Sanchez, P. Ponce, et al.\n(2018) Aggregating local image descriptors into compared codes.\nICPRAI , 2018.",
          "bbox": [
            60,
            539,
            323,
            572
          ]
        },
        {
          "type": "paragraph",
          "content": "9. Y. Jia, E. Shelhamer, J. Dunham, K. Jarar, L. R. Cong, B. J. Bruck,\nT. Zeppenfeld, and A. Waibel. Commercial structural architectures for fast\nfast feature embbedding. arXiv:1408.5993 , 2014.",
          "bbox": [
            60,
            574,
            323,
            606
          ]
        },
        {
          "type": "paragraph",
          "content": "[20] A. Krizhevsky. Learning multiple layers of features from tiny im-\nages. Tech Report , 2009.",
          "bbox": [
            60,
            607,
            323,
            628
          ]
        },
        {
          "type": "paragraph",
          "content": "[1] A. Krizhevsky, I. Sutskever, and G. Hinton. Imagenet classification\nwith deep convolutional neural networks. In NIPS , 2012.",
          "bbox": [
            60,
            629,
            323,
            651
          ]
        },
        {
          "type": "paragraph",
          "content": "22. Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Roux,\nand P. W. Hamprecht, \"Self learning by mimicking human behavior,\"\nwritten zip code recognition, Neural computation , 1989.",
          "bbox": [
            60,
            651,
            323,
            684
          ]
        },
        {
          "type": "paragraph",
          "content": "[23] Y. LeCun, L. Bottou, G. C. Orr, and K.-R. Mller. Efficient backpropagation.\nIn Neural Networks: Tricks of the trade, pages 9–50. Springer, 1998.",
          "bbox": [
            59,
            685,
            323,
            707
          ]
        },
        {
          "type": "paragraph",
          "content": "[24] C.-Y. Lee, S. Xie, P. Gallagher, Z. Zhang, and Z. Tu. Deeply-\nsupervised nets. arXiv:1409.5185 , 2014.",
          "bbox": [
            60,
            707,
            323,
            728
          ]
        },
        {
          "type": "paragraph",
          "content": "[25] M. Lin, Q. Chen, and S. Yan. Network in network. arXiv:1312.4400,\n2013.",
          "bbox": [
            60,
            730,
            323,
            751
          ]
        },
        {
          "type": "paragraph",
          "content": "2. T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Peron, D. Ramanan,\n P. Dollár, and B. Schuller,“Microsoft COCO: Common objects in\ncontext,” in ECCV , 2014.",
          "bbox": [
            60,
            753,
            323,
            784
          ]
        },
        {
          "type": "paragraph",
          "content": "[27] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks\nfor semantic segmentation. In CVPR , 2015.",
          "bbox": [
            60,
            786,
            323,
            807
          ]
        },
        {
          "type": "paragraph",
          "content": "[26] G. Montifar, R. Pascanu, K. Cho, and Y. Bengio. On the number of\nlinear regions of deep neural networks. In NIPS , 2014.",
          "bbox": [
            347,
            85,
            617,
            106
          ]
        },
        {
          "type": "paragraph",
          "content": "[29] V. Nair and G. E. Hinton. Rectified linear units improve restricted\nboltzmann machines. In ICML , 2010.",
          "bbox": [
            347,
            107,
            617,
            128
          ]
        },
        {
          "type": "paragraph",
          "content": "[30] F. Perronnin and C. Dance. Fisher kernels on visual vocabularies for\nimage categorization. In CVPR , 2007.",
          "bbox": [
            347,
            130,
            616,
            151
          ]
        },
        {
          "type": "paragraph",
          "content": "[31] T. Raiko, H. Valpola, and Y. LeCun. Deep learning made easier by\nlinear transformations in perceptrons. In AISTATS , 2012.",
          "bbox": [
            347,
            152,
            616,
            173
          ]
        },
        {
          "type": "paragraph",
          "content": "[12] S. Ren, K. He, R. Girshick, and J. Sun. Faster R-CNN: Towards\nreal-time object detection with region proposal networks. In NIPS ,\n2015.",
          "bbox": [
            347,
            174,
            617,
            207
          ]
        },
        {
          "type": "paragraph",
          "content": "[33] B. D. Ripley. Pattern recognition and neural networks . Cambridge\nuniversity press, 1996.",
          "bbox": [
            347,
            209,
            616,
            229
          ]
        },
        {
          "type": "paragraph",
          "content": "[34] A. Romero, N. Ballas, S. E. Kahou, A. Chassang, C. Gatta, and\nY. Bengio. Fitnets: Hints for thin deep nets. In ICLR , 2015.",
          "bbox": [
            347,
            231,
            616,
            252
          ]
        },
        {
          "type": "paragraph",
          "content": "[9] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, M. S.\nShen, and Y. W. Li. PASCAL 2012: International Conference on\nlarge scale visual recognition, dallas, USA; 1809-0372, 2012.",
          "bbox": [
            347,
            253,
            617,
            285
          ]
        },
        {
          "type": "paragraph",
          "content": "[46] A. M. Saxe, L. J. McClelland, and S. Ganguli. Experiments on test\nnetworks for the analysis of learning in deep linear neural networks.\narXiv:1312.6329 , 2013.",
          "bbox": [
            347,
            286,
            617,
            318
          ]
        },
        {
          "type": "paragraph",
          "content": "[37] N. N. Schraulolph. Accelerated gradient descent by factor-centering\ndecomposition. Technical report, 1998.",
          "bbox": [
            347,
            320,
            617,
            341
          ]
        },
        {
          "type": "paragraph",
          "content": "[38] N. E. Schraadhoff, Centering neural network gradient factors, In:\nNeural Networks: Tricks of the Trade , page 207–228. Springer,\n2016.",
          "bbox": [
            347,
            342,
            617,
            373
          ]
        },
        {
          "type": "paragraph",
          "content": "P. Sermanet, D. Eigen, X. Zhang, M. Matta, R. Fergus, and Y. Le-\nlie. 1st International Conference on Machine Learning and Data\nMining using convolutional networks. In ICML , 2014.",
          "bbox": [
            347,
            376,
            617,
            408
          ]
        },
        {
          "type": "paragraph",
          "content": "[40] K. Simonyan and A. Zisserman. Very deep convolutional networks\nfor large-scale image recognition. In ICLR , 2015.",
          "bbox": [
            347,
            409,
            617,
            430
          ]
        },
        {
          "type": "paragraph",
          "content": "[14] R. K. Srivastava, K. Greff, and J. Schmidhuber. Highway networks,\narXiv:1505.00387 , 2015.",
          "bbox": [
            347,
            431,
            616,
            453
          ]
        },
        {
          "type": "paragraph",
          "content": "[42] R. K. Srivastava, K. Greff, and J. Schmidhuber. Training very deep\nnetworks. 1507.06228 , 2015.",
          "bbox": [
            347,
            454,
            616,
            475
          ]
        },
        {
          "type": "paragraph",
          "content": "[4] C. Szegedy, W. Li, Y. Ju, P. Sermant, S. Reed, D. Anguiano, D. Er-\nnach, and A. Rabinovich, Going deeper with convolu-\ntions, In CVPR , 2015.",
          "bbox": [
            347,
            476,
            617,
            508
          ]
        },
        {
          "type": "paragraph",
          "content": "[44] R. Szeliski. Fast surface interpolation using hierarchical basis func-\ntions. TPAMI , 1990.",
          "bbox": [
            347,
            510,
            617,
            530
          ]
        },
        {
          "type": "paragraph",
          "content": "[45] R. Szeliski. Locally adapted hierarchical basis preconditioning. In\nSIGGRAPH , 2006.",
          "bbox": [
            347,
            532,
            616,
            552
          ]
        },
        {
          "type": "paragraph",
          "content": "[4] T. Vatan, T. Raiso, H. Valpola, and Y. LeCun. Pushing stochas-\ntic gradient towards second-order methods—backpropagation learn-\ning with transformations in nonlinearities. In Neural Information\nProcessing , 2013.",
          "bbox": [
            347,
            554,
            616,
            598
          ]
        },
        {
          "type": "paragraph",
          "content": "[47] A. Vedaldi and B. Fulkerson. VLFeat: An open and portable library\nof computer vision algorithms, 2008.",
          "bbox": [
            347,
            599,
            617,
            620
          ]
        },
        {
          "type": "paragraph",
          "content": "[48] W. Venables and B. Ripley. Modern applied statistics with s-plus,\n1999.",
          "bbox": [
            347,
            621,
            617,
            641
          ]
        },
        {
          "type": "paragraph",
          "content": "[49] M. D. Zeiler and R. Fergus. Visualizing and understanding convolu-\ntional neural networks. In ECCV , 2014.",
          "bbox": [
            347,
            644,
            617,
            665
          ]
        }
      ],
      "text": "References\n\nY. Bengio, P. Simard and P. Frasconi . Learning long-term dependents\non past experiences. In Proc. IEEE Transactions on Information\nNetworks , 5(2):157–166, 1994.\n\n[2] C. M. Bishop, Neural networks for pattern recognition . Oxford\nUniversity press, 1995.\n\n[3] W. L. Briggs, S. F. McCormick, et al. A Multigrid Tutorial . Siam,\n2000.\n\n[6] K. Chaffatil, V. Lemovsky, A. Vedraldi, and A. Zisserman. The deviance\nof language: an evaluation of recent feature encoding methods.\nIn BMVC , 2011.\n\n[1] M. Everingham, L. Van Gool, K. E. Williams, J. Winn, and J. M. Swinski, \"Computer vision\nevaluation through borderline detection of objects (VOC) challenge\", IGCV,\npages 303–338, 2010.\n\n[6] R. Girshick. Fast R-CNN. In ICCV , 2015.\n\n19. R. Girshick, J. Donahue, T. Darrell, and J. Malik. Risk reduction for\nconvex object detection and segmentation. In\nCVPR , 2014.\n\n[8] X. Glorot and Y. Bengio. Understanding the difficulty of training\ndeep feedforward neural networks. In AISTATS , 2010.\n\n[9] I. J. Goodfellow, D. Warde-Farley, M. Mirza, A. Courville, and\nY. Bengio, Maxout networks. arXiv:1302.4389 , 2013.\n\n10 K. He and J. Sun. Convolutional neural networks at constrained time\ncost. In CVPR , 2015.\n\n#1 K. He, X. Zhang, S. Ren, and J. Sun. Spatial pyramid pooling in deep\nconvolutional networks for visual recognition. In ECCV , 2014.\n\n6. Ke, H., X. Zhang, R. Ren, and J. Sun. Delving deep into rectifier\ngains: Human-level performance on imagenet classification. In\nICCT , 2017.\n\n[3] G. E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, et al.\nDeep residual learning for convolutional neural networks, in: Proceedings of\nadaption to feature detectors, pp. 127-158(2012).\n\n[4] S. Hochreiter, Untersuchungen zu dynamischen neuronalen netzen,\nDiploma thesis , TU Munich, 1991.\n\n[15] S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural\ncomputation , 9(8):1735–1780, 1997.\n\n[16] S. Ioffi and C. Szegedy. Batch normalization: Accelerating deep\nnetwork training by reducing internal covariate shift. In ICML , 2015.\n\n[17] H. Jegou, M. Douze, and C. Schmid. Product quantization for nearest\nneighbor search. TPAMI , 33, 2011.\n\n[1] H. Jegou, F. Perronnin, M. Douze, J. Sanchez, P. Ponce, et al.\n(2018) Aggregating local image descriptors into compared codes.\nICPRAI , 2018.\n\n9. Y. Jia, E. Shelhamer, J. Dunham, K. Jarar, L. R. Cong, B. J. Bruck,\nT. Zeppenfeld, and A. Waibel. Commercial structural architectures for fast\nfast feature embbedding. arXiv:1408.5993 , 2014.\n\n[20] A. Krizhevsky. Learning multiple layers of features from tiny im-\nages. Tech Report , 2009.\n\n[1] A. Krizhevsky, I. Sutskever, and G. Hinton. Imagenet classification\nwith deep convolutional neural networks. In NIPS , 2012.\n\n22. Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Roux,\nand P. W. Hamprecht, \"Self learning by mimicking human behavior,\"\nwritten zip code recognition, Neural computation , 1989.\n\n[23] Y. LeCun, L. Bottou, G. C. Orr, and K.-R. Mller. Efficient backpropagation.\nIn Neural Networks: Tricks of the trade, pages 9–50. Springer, 1998.\n\n[24] C.-Y. Lee, S. Xie, P. Gallagher, Z. Zhang, and Z. Tu. Deeply-\nsupervised nets. arXiv:1409.5185 , 2014.\n\n[25] M. Lin, Q. Chen, and S. Yan. Network in network. arXiv:1312.4400,\n2013.\n\n2. T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Peron, D. Ramanan,\n P. Dollár, and B. Schuller,“Microsoft COCO: Common objects in\ncontext,” in ECCV , 2014.\n\n[27] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks\nfor semantic segmentation. In CVPR , 2015.\n\n[26] G. Montifar, R. Pascanu, K. Cho, and Y. Bengio. On the number of\nlinear regions of deep neural networks. In NIPS , 2014.\n\n[29] V. Nair and G. E. Hinton. Rectified linear units improve restricted\nboltzmann machines. In ICML , 2010.\n\n[30] F. Perronnin and C. Dance. Fisher kernels on visual vocabularies for\nimage categorization. In CVPR , 2007.\n\n[31] T. Raiko, H. Valpola, and Y. LeCun. Deep learning made easier by\nlinear transformations in perceptrons. In AISTATS , 2012.\n\n[12] S. Ren, K. He, R. Girshick, and J. Sun. Faster R-CNN: Towards\nreal-time object detection with region proposal networks. In NIPS ,\n2015.\n\n[33] B. D. Ripley. Pattern recognition and neural networks . Cambridge\nuniversity press, 1996.\n\n[34] A. Romero, N. Ballas, S. E. Kahou, A. Chassang, C. Gatta, and\nY. Bengio. Fitnets: Hints for thin deep nets. In ICLR , 2015.\n\n[9] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, M. S.\nShen, and Y. W. Li. PASCAL 2012: International Conference on\nlarge scale visual recognition, dallas, USA; 1809-0372, 2012.\n\n[46] A. M. Saxe, L. J. McClelland, and S. Ganguli. Experiments on test\nnetworks for the analysis of learning in deep linear neural networks.\narXiv:1312.6329 , 2013.\n\n[37] N. N. Schraulolph. Accelerated gradient descent by factor-centering\ndecomposition. Technical report, 1998.\n\n[38] N. E. Schraadhoff, Centering neural network gradient factors, In:\nNeural Networks: Tricks of the Trade , page 207–228. Springer,\n2016.\n\nP. Sermanet, D. Eigen, X. Zhang, M. Matta, R. Fergus, and Y. Le-\nlie. 1st International Conference on Machine Learning and Data\nMining using convolutional networks. In ICML , 2014.\n\n[40] K. Simonyan and A. Zisserman. Very deep convolutional networks\nfor large-scale image recognition. In ICLR , 2015.\n\n[14] R. K. Srivastava, K. Greff, and J. Schmidhuber. Highway networks,\narXiv:1505.00387 , 2015.\n\n[42] R. K. Srivastava, K. Greff, and J. Schmidhuber. Training very deep\nnetworks. 1507.06228 , 2015.\n\n[4] C. Szegedy, W. Li, Y. Ju, P. Sermant, S. Reed, D. Anguiano, D. Er-\nnach, and A. Rabinovich, Going deeper with convolu-\ntions, In CVPR , 2015.\n\n[44] R. Szeliski. Fast surface interpolation using hierarchical basis func-\ntions. TPAMI , 1990.\n\n[45] R. Szeliski. Locally adapted hierarchical basis preconditioning. In\nSIGGRAPH , 2006.\n\n[4] T. Vatan, T. Raiso, H. Valpola, and Y. LeCun. Pushing stochas-\ntic gradient towards second-order methods—backpropagation learn-\ning with transformations in nonlinearities. In Neural Information\nProcessing , 2013.\n\n[47] A. Vedaldi and B. Fulkerson. VLFeat: An open and portable library\nof computer vision algorithms, 2008.\n\n[48] W. Venables and B. Ripley. Modern applied statistics with s-plus,\n1999.\n\n[49] M. D. Zeiler and R. Fergus. Visualizing and understanding convolu-\ntional neural networks. In ECCV , 2014.",
      "markdown": "## References\n\nY. Bengio, P. Simard and P. Frasconi . Learning long-term dependents on past experiences. In Proc. IEEE Transactions on Information Networks , 5(2):157–166, 1994.\n\n[2] C. M. Bishop, Neural networks for pattern recognition . Oxford University press, 1995.\n\n[3] W. L. Briggs, S. F. McCormick, et al. A Multigrid Tutorial . Siam, 2000.\n\n[6] K. Chaffatil, V. Lemovsky, A. Vedraldi, and A. Zisserman. The deviance of language: an evaluation of recent feature encoding methods. In BMVC , 2011.\n\n[1] M. Everingham, L. Van Gool, K. E. Williams, J. Winn, and J. M. Swinski, \"Computer vision evaluation through borderline detection of objects (VOC) challenge\", IGCV, pages 303–338, 2010.\n\n[6] R. Girshick. Fast R-CNN. In ICCV , 2015.\n\n19. R. Girshick, J. Donahue, T. Darrell, and J. Malik. Risk reduction for convex object detection and segmentation. In CVPR , 2014.\n\n[8] X. Glorot and Y. Bengio. Understanding the difficulty of training deep feedforward neural networks. In AISTATS , 2010.\n\n[9] I. J. Goodfellow, D. Warde-Farley, M. Mirza, A. Courville, and Y. Bengio, Maxout networks. arXiv:1302.4389 , 2013.\n\n10 K. He and J. Sun. Convolutional neural networks at constrained time cost. In CVPR , 2015.\n\n#1 K. He, X. Zhang, S. Ren, and J. Sun. Spatial pyramid pooling in deep convolutional networks for visual recognition. In ECCV , 2014.\n\n6. Ke, H., X. Zhang, R. Ren, and J. Sun. Delving deep into rectifier gains: Human-level performance on imagenet classification. In ICCT , 2017.\n\n[3] G. E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, et al. Deep residual learning for convolutional neural networks, in: Proceedings of adaption to feature detectors, pp. 127-158(2012).\n\n[4] S. Hochreiter, Untersuchungen zu dynamischen neuronalen netzen, Diploma thesis , TU Munich, 1991.\n\n[15] S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural computation , 9(8):1735–1780, 1997.\n\n[16] S. Ioffi and C. Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In ICML , 2015.\n\n[17] H. Jegou, M. Douze, and C. Schmid. Product quantization for nearest neighbor search. TPAMI , 33, 2011.\n\n[1] H. Jegou, F. Perronnin, M. Douze, J. Sanchez, P. Ponce, et al. (2018) Aggregating local image descriptors into compared codes. ICPRAI , 2018.\n\n9. Y. Jia, E. Shelhamer, J. Dunham, K. Jarar, L. R. Cong, B. J. Bruck, T. Zeppenfeld, and A. Waibel. Commercial structural architectures for fast fast feature embbedding. arXiv:1408.5993 , 2014.\n\n[20] A. Krizhevsky. Learning multiple layers of features from tiny images. Tech Report , 2009.\n\n[1] A. Krizhevsky, I. Sutskever, and G. Hinton. Imagenet classification with deep convolutional neural networks. In NIPS , 2012.\n\n22. Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Roux, and P. W. Hamprecht, \"Self learning by mimicking human behavior,\" written zip code recognition, Neural computation , 1989.\n\n[23] Y. LeCun, L. Bottou, G. C. Orr, and K.-R. Mller. Efficient backpropagation. In Neural Networks: Tricks of the trade, pages 9–50. Springer, 1998.\n\n[24] C.-Y. Lee, S. Xie, P. Gallagher, Z. Zhang, and Z. Tu. Deeplysupervised nets. arXiv:1409.5185 , 2014.\n\n[25] M. Lin, Q. Chen, and S. Yan. Network in network. arXiv:1312.4400, 2013.\n\n2. T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Peron, D. Ramanan, P. Dollár, and B. Schuller,“Microsoft COCO: Common objects in context,” in ECCV , 2014.\n\n[27] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks for semantic segmentation. In CVPR , 2015.\n\n[26] G. Montifar, R. Pascanu, K. Cho, and Y. Bengio. On the number of linear regions of deep neural networks. In NIPS , 2014.\n\n[29] V. Nair and G. E. Hinton. Rectified linear units improve restricted boltzmann machines. In ICML , 2010.\n\n[30] F. Perronnin and C. Dance. Fisher kernels on visual vocabularies for image categorization. In CVPR , 2007.\n\n[31] T. Raiko, H. Valpola, and Y. LeCun. Deep learning made easier by linear transformations in perceptrons. In AISTATS , 2012.\n\n[12] S. Ren, K. He, R. Girshick, and J. Sun. Faster R-CNN: Towards real-time object detection with region proposal networks. In NIPS , 2015.\n\n[33] B. D. Ripley. Pattern recognition and neural networks . Cambridge university press, 1996.\n\n[34] A. Romero, N. Ballas, S. E. Kahou, A. Chassang, C. Gatta, and Y. Bengio. Fitnets: Hints for thin deep nets. In ICLR , 2015.\n\n[9] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, M. S. Shen, and Y. W. Li. PASCAL 2012: International Conference on large scale visual recognition, dallas, USA; 1809-0372, 2012.\n\n[46] A. M. Saxe, L. J. McClelland, and S. Ganguli. Experiments on test networks for the analysis of learning in deep linear neural networks. arXiv:1312.6329 , 2013.\n\n[37] N. N. Schraulolph. Accelerated gradient descent by factor-centering decomposition. Technical report, 1998.\n\n[38] N. E. Schraadhoff, Centering neural network gradient factors, In: Neural Networks: Tricks of the Trade , page 207–228. Springer, 2016.\n\nP. Sermanet, D. Eigen, X. Zhang, M. Matta, R. Fergus, and Y. Lelie. 1st International Conference on Machine Learning and Data Mining using convolutional networks. In ICML , 2014.\n\n[40] K. Simonyan and A. Zisserman. Very deep convolutional networks for large-scale image recognition. In ICLR , 2015.\n\n[14] R. K. Srivastava, K. Greff, and J. Schmidhuber. Highway networks, arXiv:1505.00387 , 2015.\n\n[42] R. K. Srivastava, K. Greff, and J. Schmidhuber. Training very deep networks. 1507.06228 , 2015.\n\n[4] C. Szegedy, W. Li, Y. Ju, P. Sermant, S. Reed, D. Anguiano, D. Ernach, and A. Rabinovich, Going deeper with convolutions, In CVPR , 2015.\n\n[44] R. Szeliski. Fast surface interpolation using hierarchical basis functions. TPAMI , 1990.\n\n[45] R. Szeliski. Locally adapted hierarchical basis preconditioning. In SIGGRAPH , 2006.\n\n[4] T. Vatan, T. Raiso, H. Valpola, and Y. LeCun. Pushing stochastic gradient towards second-order methods—backpropagation learning with transformations in nonlinearities. In Neural Information Processing , 2013.\n\n[47] A. Vedaldi and B. Fulkerson. VLFeat: An open and portable library of computer vision algorithms, 2008.\n\n[48] W. Venables and B. Ripley. Modern applied statistics with s-plus, 1999.\n\n[49] M. D. Zeiler and R. Fergus. Visualizing and understanding convolutional neural networks. In ECCV , 2014.\n\n"
    }
  ],
  "full_text": "[Figure]\n\nThis CVPR paper is the Open Access version, provided by the Computer Vision Foundation.\nExcept for this watermark, it is identical to the version available on IEEE Xplore.\n\nDeep Residual Learning for Image Recognition\n\nKaiming He\nXiangyu Zhang\nShaoqing Ren\nJian Sun\n\nMicrosoft Research\n\n{kahe, v-xiang, v-shren, jiansun}@microsoft.com\n\nAbstract\n\nDeeper neural networks are more difficult to train. We\npresent a residual learning framework to ease the training\nof networks that are substantially deeper than those used\npreviously. We explicitly reformulate the layers as learn-\ning residual functions with reference to the layer inputs, in-\nstead of learning unrefereed functions. We provide com-\nprehensive empirical evidence showing that these residual\nnetworks are easier to optimize, and can gain accuracy from\ninput changes. The proposed method can also be used to\nevaluate residual nets with a depth of up to 152 layers—8 x\ndeeper than VGG nets [40] but still having lower complex-\nity. An ensemble of these residual nets achieves 3.57 % error\non the ImageNet test set. This result won the 1st place on the\nILSVRC 2015 classification task. We also present analysis\non CIFAR-10 with 100 and 1000 layers.\n\nThe depth of representations is of central importance\nfor many visual recognition tasks. Solely due to our ex-\ntremely deep representations, we obtain a 28 % relative im-\nprovement on the COCO object detection dataset. Deep\nresidual nets are foundations of our submissions to ILSVRC\n& COCO 2015 competitions 1 , where we also won the 1st\nplaces on the tasks of ImageNet detection, ImageNet local-\nization, COCO detection, and COCO segmentation.\n\n1. Introduction\n\nDeep convolutional neural networks [22, 21] have led\nto a series of breakthroughs for image classification [21,\n49, 39] . Deep networks naturally integrate low/mid/high-\nlevel features [49] and classifiers in an end-to-end multi-\nlayer fashion, and the “ levels ” of features can be enriched\nby the number of stacked layers (depth). Recent evidence\nhas found that convolutional neural networks perform well\nand the leading results [40, 43, 12, 16] on the challenging\nImageNet dataset [35] all exploit “ very deep ” [40] models,\nwith a depth of sixteen [40] to thirty [16] . Many other non-\ntrivial visual recognition tasks [7, 11, 6, 32, 27] have also\n\ngreatly benefited from very deep models.\n\n[Figure]\n\nFigure. 1. Training error (left) and test error (right) on CIFAR-10\nwith 20-layer and 56-layer \"plain\" networks. The deeper network\nhas higher training error, and thus test error. Similar phenomena\non ImageNet is presented in Fig. 4 .\n\nDriven by the significance of depth, a question arises: Is\nLearning better networks as easy as stacking more layers?\nAn obstacle to answering this question was the notorious\nproblem of vanishing/exploding gradients [14, 1, 8] , which\nhamper convergence from the beginning. This problem,\nhowever, has been largely addressed by normalized initial-\nization [23, 8, 36, 12] and intermediate normalization layers\n[16] , which enable networks with tens of layers to start con-\nverging for stochastic gradient descent (SGD) with back-\npropagation [22] .\n\nWhen deeper networks are able to start converging, a\ndegradation problem has been exposed: with the network\ndepth increasing, accuracy gets saturated (which might be\nunsurprising) and then degrades rapidly. Unexpectedly,\nsuch degradation is not caused by overfitting , and adding\nmore layers to a suitably deep model leads to higher train-\ning error , as reported in [10, 41] and thoroughly verified by\nour experiments. Fig. 1 shows a typical example.\n\nThe degradation of (training accuracy) indicates that not\nall systems are similarly easy to optimize. Let us consider a\nshallower architecture and its deeper counterpart that adds\nmore layers onto it. There exists a solution by construction\nto the deeper model: the added layers are identity mapping,\nand the other layers are copied from the learned shallower\nmodel. The existence of this constructed solution indicates\nthat a deeper model should produce no higher training error\nthan its shallower counterpart. But experiments show that\nour current solvers on hand are unable to find solutions that\n\n' http://image-net.org/challenges/LSVRC/2015, and\n' http://mccoco.org/dataset/detections-challenge2015 .\n\n770\n\n---\n\n[Figure]\n\nFigure 2. Residual learning: a building block.\n\nare comparably good or better than the constructed solution\n(or unable to do so in feasible time).\n\nIn this paper, we address the degradation problem by\nintroducing a deep residual learning framework. In-\nstead of hoping each few stacked layers directly fit a\ndesired underlying mapping, we explicitly let these lay-\ners fit a residual mapping. Formally, denoting the desired\nunderlying mapping as $\\hat{H}(x)$ , we let the stacked nonlinear\nlayers fit another mapping of $\\mathcal{F}(x)=\\hat{\\mathcal{F}}(x)-\\hat{H}(x)\\cdot x$ . The orig-\ninal mapping is recorded as $f(x)$ . We hypothesize that it\nis possible that the residual mapping may be the same as\nthe original, unreferenced mapping. To the extreme, if an\nidentity mapping were optimal, it would be easier to push\nthe residual to zero than to fit an identity mapping by a stack\nof nonlinear layers.\n\nThe formulation of $\\mathcal{F}(x) \\times x$ can be realized by feedfor-\nward neural networks with “ shortcut connections ” (Fig. 2 ).\nShortcut connections [22, 33, 48] are those skipping one or\nmore layers. In our case, the shortcut connections simply\nperform identity mapping, and their outputs are added to\nthe outputs of the stacked layers (Fig. 2 ). Identity short-\ncut connections add further extra parameters not com-\npletely learnable. They enhance the network and can be trained\nend-to-end by SGD with backpropagation, and can be eas-\nily implemented using common libraries ( e.g., Cafe [19] )\nwithout modifying the solvers.\n\nWe present comprehensive experiments on ImageNet\n[35] to show the degradation problem and evaluate our\nmethod. We show that: 1) Our extremely deep residual nets\nare easy to optimize, but the counterpart \"plain\" nets (that\nsimply stack layers) exhibit higher training error when the\ndepth decreases; 2) Our deep residual nets can easily enjoy\naccuracy gains from greatly increased depth, producing re-\nsults substantially better than previous networks.\n\nSimilar phenomena are also shown on the CIFAR-10 set\n[20] , suggesting that the optimization difficulties and the\neffects of our method are not just akin to a particular dataset.\nIn order to explore the impact of the training procedure, we look\nover 100 layers, and explore models with over 1000 layers.\n\nOn the ImageNet classification dataset [35] , we obtain\nexcellent results by extremely deep residual nets. Our 152-\nyear residual net is the deepest network ever present\nin ImageNet. In Table 1 , we show the error matrix of\nnets [40] . Our ensemble has 3.57 % top-5 error on the\n\nImageNet test set, and won the 1st place in the ILSVRC\n2015 classification competition. The extremely deep rep-\nresentations also have excellent generalization performance\non other recognition tasks, and lead us to further win the\n1st place on: ImageNet detection , ImageNet localization ,\nImageNet measurement , and ImageNet education . In\nCOCO 2015 competitions. This strong evidence shows that\nthe residual learning principle is generic, and we expect that\nit is applicable in other vision and non-vision problems.\n\n2. Related Work\n\nResidual Representations. In image recognition, VLD\n[18] is a representation that encodes by the residual vectors\nwith respect to a dictionary, and Fisher Vector [30] can be\nformulated as a probabilistic version [18] of VLD. Both\nof them are powerful shallow representations for image re-\ntrieval and classification [4, 47] . For vector quantization,\nencoding residual vectors [17] is shown to be more effec-\ntive than encoding original vectors.\n\nIn low-level vision and computer graphics, for solv-\ning Partial Differential Equations (PDEs), the widely used\nMultigrid method [3] reformulates the system as subprob-\nlems at multiple scales, where each subproblem is respon-\nsible for the residual solution between a coarser and a finer\nscale. An alternative to Multigrid is hierarchical basis pre-\nconditioning [44, 45] , which relies on variables that repre-\nsent residual vectors between two scales. It has been shown\n[3, 44, 45] that these solvers converge much faster than stan-\ndard solvers that are unaware of the residual nature of the\nsolutions. These methods suggest that a good reformulation\nor preconditioning can simplify the optimization.\n\nShortcut Connections. Practices and theories that lead to\nshortcut connections [2, 33, 48] have been studied for a long\ntime. An early practice of training multi-layer perceptrons\n(MLPs) is to add a linear layer connected from the network\ninput to the output [33, 48] . In [43, 24] , a few interme-\ndiates layers are directly connected to auxiliary classifiers\nfor additional learning/explaining/identifying. The papers\nof [25, 37, 31, 46] include a few more intermediate\nsponses, gradients, and propagated errors, implemented by\nshortcut connections. In [43] , an \"inception\" layer is com-\nposed of a shorter branch and a few deeper branches.\n\nConcurrent with our work, “ highway networks ” [41, 42]\npresent shortcut connections with gating functions [15] .\nThese gates are data-dependent and have parameters, in\ncontrast to our identity shortcuts that are parameter-free.\nWhen a gated shortcut is “ closed ” (approaching zero), the\nlayers in highway networks represent non-residual func-\ntions. On the contrary, our formulation always learns\nresidual functions; our identity shortcuts are never closed,\nand all information is always passed through, with addi-\ntional residual functions to be learned. In addition, high-\n\n1\n\n---\n\nway networks have not demonstrated accuracy gains with\nextremely increased depth (e.g., over 100 layers).\n\n3. Deep Residual Learning\n\n3.1. Residual Learning\n\nLet us consider $\\mathcal{H}(\\mathbf{x})$ as an underlying mapping to be\nfit by a few stacked layers (not necessarily the entire net),\nwith $\\mathbf{x}$ denoting the inputs to the first of these layers. If one\nhypothesizes that multiple nonlinear layers can asymptoti-\ncally approximate complicated functions$^{9}$ , then it is equiv-\nalent to hypothesize that they can asymptotically approxi-\nmate the residual functions, i.e., $\\mathcal{H}(\\mathbf{x}) - \\mathbf{x}$ (assuming that\nthe input and output are of the same dimensions). So\nrather than expect stacked layers to approximate $\\mathcal{H}(\\mathbf{x})$ , we\nexplicitly let these layers approximate a residual function\n$\\mathcal{F}(\\mathbf{x}) := \\mathcal{H}(\\mathbf{x}) - \\mathbf{x}$ . The original function thus becomes\n$\\mathcal{F}(\\mathbf{x}) + \\mathbf{x}$ . Although both forms should be able to asymptot-\nically approximate the desired functions (as hypothesized),\nthe ease of learning might be different.\n\nThis reformulation is motivated by the counterintuitive\nphenomena about the degradation problem (Fig. 1 , left). As\nwe discussed in the introduction, if the added layers can\nbe constructed as identity mappings, a deeper model should\nhave training error no greater than its shallower counter-\npart. The degradation problem suggests that the solvers\nneed to find a diffusion term appropriate for mapping\nby multiple nonlinear layers. With the residual error refor-\nmulation, if identity mappings are optimal, the solvers\nmay simply drive the weights of the multiple nonlinear lay-\ners toward zero to approach identity mappings.\n\nIn real cases, it is unlikely that identity mappings are op-\ntimal, but our reformulation may help to precondition the\nproblem. If the optimal function is closer to an identity\nmapping than to a zero mapping, it should be easier for the\nsolver to find the perturbations with reference to an identity\nmapping. This might be the case for the Identity Function\nby experiments (Fig. 7 ) that the learned residual functions in\ngeneral have small responses, suggesting that identity map-\npings provide reasonable preconditioning.\n\n3.2. Identity Mapping by Shortcut\n\nWe adopt residual learning to every few stacked layers.\nA building block is shown in Fig. 2 . Formally, in this paper\nwe consider a building block defined as:\n\n$$\ny=\\mathcal{F}\\left(x,\\left\\{W_{i}\\right\\}\\right)+x . \\quad(1)\n$$\n\nHere x and y are the input and output vectors of the lay-\ners considered. The function $\\mathcal{F}(x, W_i)$ represents the\nresidual mapping to be learned. For the example in Fig. 2 ,\nthat has two layers, $\\mathcal{F} = W_1 \\sigma(W_1 x)$ in which $\\sigma$ denotes\n\nReLU [29] and the biases are omitted for simplifying no-\ntations. The operation $\\mathcal{F}+x$ is performed by a shortcut\nconnection and element-wise addition. We adopt the sec-\nond nonlinearity after the addition (i.e., $\\sigma(y)$, see Fig. 2 ).\n\nThe shortcut connections in Eqn.(1) introduce neither ex-\ntra parameter nor computation complexity. This is not only\nattractive in practice but also important in our comparisons\nbetween plain and residual networks. We can fairly com-\nbine these advantages to get more advanced models with the\nsame number of parameters, depth, width, and computa-\ntional cost (except for the negligible element-wise addition).\n\nThe dimensions of $\\mathcal{X}$ and $\\mathcal{T}$ must be equal in Eqn.(1).\nIf this is not the case (e.g., when changing the input/output\nchannels), we can perform a linear projection $W_{s}$ by the\nshortcut connections to match the dimensions:\n\n$$\ny=\\mathcal{F}\\left(x,\\left\\{W_{i}\\right\\}\\right)+W_{s} x . \\quad(2)\n$$\n\nWe can also use a square matrix $W_r$ in Eqn.(1). But we will\nshow by experiments that the identity mapping is sufficient\nfor addressing the degradation problem and is economical,\nand thus $W_r$ is only used when matching dimensions.\n\nThe form of the residual function $F$ is flexible. Exper-\niments in this paper involve a function $F$ that has two or\nthree parameters, and which is not simple. However, for\n$F$ has only a single layer, Eqn. (1) is similar to a linear layer:\n$y = W_1 x + x$ , for which we have not observed advantages.\n\nWe also note that although the above notations are about\nfully-connected layers for simplicity, they are applicable to\nconvolutional layers. The function $f(x,W_{i}^{j})$ can represent\na pair of $j$ -dimensional weights and $W_{i}^{j}$ is the weight matrix ded-\niction is performed on two feature maps, channel by channel.\n\n3.3. Network Architectures\n\nWe have tested various plain/residual nets, and have ob-\nserved consistent phenomena. To provide instances for dis-\ncussion, we describe two models for ImageNet as follows,\n\nPlain Network. Our plain baselines (Fig. 3 , middle) are\nmainly inspired by the philosophy of VGG nets [40] (Fig. 3 ,\nleft). The convolutional layers mostly have 3×3 filters and\nfollow two simple design rules: (i) for the same output\nfeature map size, the layers have the same number of fil-\nters; and (ii) if the feature map size is halved, the num-\nber of filters is doubled so as to preserve the time com-\nplexity per layer. We perform downsampling directly by\nconvolutional layers that have a stride of 2. The network\nends with a global average pooling layer and a 1000-way-\nfully-connected layer with softmax. The total number of\nweighted layers is 34 in Fig. 3 (middle).\n\nIt is worth noting that our model has fewer filters and\nlower complexity than VGG nets [40] (Fig. 3 , left). Our 34-\nlayer baseline has 3.6 billion FLOPs (multiply-adds), which\nis only 18% of VGG-19 (9.6 billion FLOPs).\n\n$^{2}$This hypothesis, however, is still an open question. See [28].\n\n1\n\n---\n\n[Figure]\n\nFigure 3. Example network architectures for ImageNet. Left: the\nViGG-19 model [40] (19.6 billion FLOPs) as a reference. Mid-\ndle: a plain network with 34 parameter layers (3.6 billion FLOPs).\nRight: a residual network with 34 parameter layers (3.6 billion\nFLOPs). The dotted shortcuts increase dimensions. Table 1 shows\nmore details and other variants.\n\nResidual Network. Based on the above plain network, we\ninsert shortcut connections (Fig. 3 , right) which turn the\nnetwork into its counterpart residual version. The identity\nshortcuts (Eqn.(1) can be directly used when the input and\noutput are of the same dimensions (solid line shortcuts in\nFig. 3 ). When the dimensions increase (dotted line shortcuts\nin Fig. 5 ), we consider two options: (A) The shortcut still\nworks but the performance is slightly worse due to the loss\nfor increasing dimensions. This option introduces no extra\nparameter; (B) The projection shortcut in Eqn.(2) is used to\nmatch dimensions (done by $1 \\times 1$ convolutions). For both\noptions, when the shortcuts go across feature maps of two\nsizes, they are performed with a stride of 2.\n\n3.4. Implementation\n\nOur implementation for ImageNet follows the practice\nin [21, 40] . The image is resized with its shorter side ran-\ndomly sampled in [26, 40] , for scale augmentation [40] .\nA 224×224 crop is randomly sampled from an image or its\nhorizontal flip, with the per-pixel mean subtracted [21] . The\nstandard color augmentation in [21] is used. We adopt batch\nnormalization (BN) [16] right after each convolution and\nbefore activation, following [16] . We initialize the weights\nas in [12] and train all plain/residual nets from scratch. We\nuse SGD with a mini-batch size of 256. The learning rate\nstarts from 0.1 and is divided by 10 when the error plateaus,\nand the models are trained for up to $60 \\times 10^4$ iterations. We\nuse a weight decay of 0.0001 and a momentum of 0.9. We\ndo not use dropout [13] , following the practice in [16] .\n\nIn testing, for comparison studies we adopt the standard\n10-copy testing [21] . For best results, we adopt the fully-\nformal form [40, 48, 12] , and average the scores\nat multiple settings were averaged such that the shorter\nside is $\\{22, 256, 384, 489, 640\\}$ .\n\n4. Experiments\n\n4.1. ImageNet Classification\n\nWe evaluate our method on the ImageNet 2012 classifi-\ncation dataset [35] that consists of 1000 classes. The models\nare trained on the 1.28 million training images, and evalu-\nated on the 50k validation images. We also obtain a final\nresult on the 100k test images, reported by the test server.\nWe evaluate both top-1 and top-5 error rates.\n\nPlain Networks. We first evaluate 18-layer and 34-layer\nplain nets. The 34-layer plain net is in Fig. 3 (middle). The\n18-layer plain net is of a similar form. See Table 1 for de-\ntailed architectures.\n\nThe results in Table 2 show that the deeper 34-layer plain\nnet has higher validation error than the shallower 18-layer\nplain net. To reveal the reason, in Fig. 7 (left) we com-\npare it with another convolutional network and the indi-\ncedure. We have observed the degradation problem + the\n\n1\n\n---\n\n<table><tr><td>layer name</td><td>output size</td><td>18-layer</td><td>34-layer</td><td>50-layer</td><td>101-layer</td><td>152-layer</td></tr><tr><td>conv1</td><td>112×112</td><td colspan=\"5\">3×3 matlab, stride 2</td></tr><tr><td>conv2_x</td><td>56×56</td><td>{3×3, 64×3×3, 64}</td><td>{3×3, 64×3×3, 64}</td><td>{1×1, 64×3×3, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64, 1×1, 64,\n\nTable 1. Architectures for ImageNet: Building blocks are shown in brackets (see also Fig. 5), with the numbers of blocks stacked. Down-\nsampling is performed by conv3, conv4, 1, and conv5_1 with a stride of 2.\n\n[Figure]\n\nFigure 4. Training on ImageNet. This curve denotes training error, and bold curves denote validation error of the center crop. Left: plain\nresiduals for all four layers; Right: ResNets of 18 and 54 layers. In this plot, the residual networks have no extra parameters compared to\ntheir plain counterparts.\n\n<table><tr><td>18 layers</td><td>plain</td><td>ResNet</td></tr><tr><td>25 layers</td><td>26.05</td><td>26.23</td></tr><tr><td>34 layers</td><td>28.54</td><td>25.03</td></tr></table>\n\nTable 2. Top-1 error ( % ) -10-cp test results on ImageNet validation.\nTop-1 error is the average value of all the columns excepting for their plain\ncounterparts. Fig. 4 shows the training procedures.\n\n34-layer plain net has higher training error throughout the\nwhole training procedure, even though the solution space\nof the 18-layer plain network is a subspace of that of the\n34-layer one.\n\nWe argue that this optimization difficulty is unlikely to\nbe caused by vanishing gradients. These plain networks are\ntrained with BN [16] , which ensures forward propagated\nsignals to have non-zero variances. We also verify that the\nbackward propagated gradients exhibit healthy norms with\nBN. So neither forward nor backward signals vanish. In\nfact, the 34-layer plain net is still able to achieve compet-\nitive accuracy (Table 3 ), suggesting that the solver works\nto some extent. We conjecture that the deep plain nets may\nhave exponentially low convergence rates, which impact the\n\nreducing of the training error). The reason for such opti-\nmization difficulties will be studied in the future.\n\nResidual Networks. Next we evaluate 18-layer and 34-\nlayer residual nets (ResNets). The baseline architectures\nare the same as the above plain nets, expect that a shortcut\nconnection is added to each pair of 3 $\\times$ 3 filters as in Fig. 3\n(right). In the first comparison (Table 2 and Fig. 4 right),\nwe use identity mapping for all shortcuts and zero-padding\nfor increasing dimensions (option A), so they have no extra\nparameter compared to the plain counterparts.\n\nWe have three major observations from Table 2 and\nFig. 4 . First, the situation is reversed with residual learn-\ning – the 34-layer ResNet is better than the 18-layer ResNet\n(by 2.8 % ). More importantly, the 34-layer ResNet exhibits\nconsiderably lower training error and is generalizable to the\nvalidation data. This indicates that the degradation problem\nis well addressed in this setting and we manage to obtain\naccuracy gains from increased depth.\n\nSecond, compared to its plain counterpart, the 34-layer\n\nWe have experimented with more training iterations (3×) and still ob-\nserved that the increase in the number of training iterations can be\nfeasibly addressed by simply using more training.\n\n774\n\n---\n\n<table><tr><td>model</td><td>top-1 err.</td><td>top-5 err.</td></tr><tr><td>VGG-16 [40]</td><td>28.07</td><td>9.33</td></tr><tr><td>GoogleLeNet [43]</td><td>-</td><td>9.15</td></tr><tr><td>PReLU-Net [12]</td><td>24.27</td><td>7.38</td></tr><tr><td>plain-34</td><td>28.54</td><td>10.02</td></tr><tr><td>ResNet-34 A</td><td>25.03</td><td>7.76</td></tr><tr><td>ResNet-34 B</td><td>24.52</td><td>7.46</td></tr><tr><td>ResNet-50</td><td>24.40</td><td>6.92</td></tr><tr><td>ResNet-50</td><td>22.85</td><td>6.71</td></tr><tr><td>ResNet-101</td><td>21.75</td><td>6.05</td></tr><tr><td>ResNet-152</td><td>21.43</td><td>5.71</td></tr></table>\n\nTable 3. Error rates (%) -10-copy testing in ImageNet validation.\nWe find that the mean and minimum values of option B\nthat only uses projections for increasing dimensions.\n\n<table><tr><td>method</td><td>top-1 err.</td><td>top-5</td></tr><tr><td>VGG [40] (ILSVRC'14)</td><td>-</td><td>8.43</td></tr><tr><td>GoogLeNet [43] (ILSVRC'14)</td><td>-</td><td>7.89</td></tr><tr><td>VGG [40] (v5)</td><td>24.4</td><td>7.1</td></tr><tr><td>PReLU-net [12]</td><td>21.59</td><td>5.77</td></tr><tr><td>BN-incoption [16]</td><td>21.99</td><td>5.8</td></tr><tr><td>ResNet-34 B</td><td>21.84</td><td>5.77</td></tr><tr><td>ResNet-34 C</td><td>21.53</td><td>5.66</td></tr><tr><td>ResNet-101</td><td>20.74</td><td>5.2</td></tr><tr><td>ResNet-101</td><td>19.87</td><td>4.66</td></tr><tr><td>ResNet-152</td><td>19.38</td><td>4.48</td></tr></table>\n\nTable 4. Error rates (%) of single-model results on the ImageNet\nvalidation set (except reported on the test set).\n\n<table><tr><td>method</td><td>top-5 err. (test)</td></tr><tr><td>VGG [40] (ILSVRC'14)</td><td>7.32</td></tr><tr><td>GoogLeNet [43] (ILSVRC'14)</td><td>6.66</td></tr><tr><td>VGG [40] (v5)</td><td>6.8</td></tr><tr><td>PReLU-net [12]</td><td>4.94</td></tr><tr><td>BN-inception [16]</td><td>4.82</td></tr><tr><td>ResNet (ILSVRC'15)</td><td>3.57</td></tr></table>\n\nTable 5. Error rates (%) of ensembles . The top-5 error is on the\ntest set of ImageNet and reported by the test server.\n\nResNet reduces the top-1 error by 3.5 % (Table 2 ), resulting\nfrom the successfully reduced training error (Fig. 4 right vs.\nleft). This comparison verifies the effectiveness of residual\nlearning on extremely deep systems.\n\nLast, we also note that the 18-layer plain-residual nets\nare comparably accurate (Table 2 ), but the 18-layer ResNet\nconverges faster (Fig. 4 right vs. left). When the net is \"not\noverly deep\" (18 layers here), the current SGD solver is still\nrelatively insensitive to the plain net. In this case, the\nResNet eases the optimization by providing faster conver-\ngence at the early stage.\n\nIdentity vs. Projection Shortcuts. We have shown that\n\nparameter-free, identity shortcuts help with training. Next\nwe investigate projection shortcuts (Eqn.(2)). In Table 3 we\ncompare three options: (A) zero-padding shortcuts are used\nfor increasing dimensions, and all shortcuts are parameter-\nized; (B) one or two parameterized shortcuts are used for in-\ntion shortcuts are used for increasing dimensions, and other\nshortcuts are identity; and (C) all shortcuts are projections.\n\n[Figure]\n\nFigure 5: A deeper residual function $F$ for ImageNet, Left: self-attention\nblock, Right: “a bottleneck” build-on block for ResNet-50v1 [19]\n\nTable 3 shows that all three options are considerable bet-\nter than the plain counterpart. B is slightly better than A. We\nargue that this is because the zero-padded dimensions in A\nindeed have no residual learning. C is marginally better than\nB, and we attribute this to the extra parameters introduced\nby many (thirteen) projection shortcuts. But the small dif-\nferences among A/B/C indicate that projection shortcuts are\nnot essential for addressing the degradation problem. So we\ndo not use option C in the rest of this paper, to reduce mem-\nory/time complexity and model sizes. Identify shortcuts are\nparticularly important for not increasing the complexity of\nthe bottleneck architectures that are introduced below.\n\nDeeper Bottleneck Architectures. Next we describe our\ndeeper nets for ImageNet. Because of concerns on the train-\ning time that we can afford, we modify the building block\nas a bottleneck design $^4$ . For each residual function $\\mathcal{F}$ , we\nuse a stack of 3 layers instead of 2 (Fig. 5 ). The three layers\nare $1 \\times 1, 3 \\times 3$ , and $1 \\times 1$ convolutions, where the $1 \\times 1$ layers\nare responsible for reducing and then increasing (restoring)\ndimensions, leaving the $3 \\times 3$ layer a bottleneck with smaller\ninput/output dimensions. Fig. 5 shows an example, where\nboth designs have similar time complexity.\n\nThe parameter-free identity shortcuts are particularly im-\nportant for the bottleneck architectures. If the identity short-\ncut in Fig. 5 (right) is replaced with projection, one can\nshow that the time complexity and model size are doubled,\nand the computation time is doubled compared to the two high-dimensional\nends. So identity shortcuts lead to more efficient models\nfor the bottleneck designs.\n\nResNet-50:\n\n$^{*}$Deeper non-bottleneck ResNets (e.g., Fig. 5 left) also gain accuracy\nfrom increased depth (as shown in CIFAR-10), but are not as economical\nas the bottleneck ResNets. So the usage of bottleneck designs is mainly due\nto the breadth and performance limitations of the original implementation\nof plain nets is also witnessed for the bottleneck design.\n\n1\n\n---\n\n34-layer net with this 3-layer bottleneck block, resulting in\na 50-layer ResNet (Table 1). We use option B for increasing\ndimensions. This model has 3.8 billion FLOPs.\n\n101-layer and 152-layer ResNets: We construct 101-\nlayer and 152-layer ResNets by using more 3-layer blocks\n(Table 1 ). Remarkably, although the depth is significantly\nincreased, the 152-layer ResNet (11.3 billion FLOPs) still\nhas lower complexity than VGG-16/19 nets (15.3/19.6 bil-\nlion FLOPs).\n\nThe 50/101/152-level ResNets are more accurate than\nthe 34-layer ones by considerable margins (Table 3 and 4 ).\nWe do not observe the degradation problem and thus en-\njoy significant accuracy gains from considerably increased\ndepth. The benefits of depth are witnessed for all evaluation\nmetrics (Table 3 and 4 ).\n\nComparisons with State-of-the-art Methods. In Table 4 ,\nwe compare with the previous best single-model results.\nOur baseline 34-layer ResNets have achieved very compet-\nitive accuracy. Our 152-layer ResNet has a single-model\ntop-5 validation error of 4.49 % . This single-model result\noutperforms all previous ensemble results (Table 5 ). We\ncombine six models of different depth to form an ensemble\n(only with two 152-layer ones at the time of submitting).\nThis leads to 3.57 % top-5 error on the test set (Table 5 ).\nThis entry won the 1st place in ISL/RVC 2015.\n\n4.2. CIFAR-10 and Analysis\n\nWe conducted more studies on the CIFAR-10 dataset\n[20] , which consists of 50k training images and 10k test-\ning images in 10 classes. We present experiments trained\non the training set and evaluated on the test set. Our focus\nis on the behaviour of extremely deep networks, but not on\npushing the state-of-the-art results, so we intentionally use\nsimple architectures as follows:\n\nThe plain/residual architectures follow the foll in Fig. 3\n(middle/right). The network inputs are $32 \\times 32$ images, with\nthe per-pixel mean subtracted. The first layer is $3 \\times 3$ convo-\nlutions. Then we use a stack of $6n$ layers with $3 \\times 3$ convo-\nlutions on the feature maps of $(32 \\times 32)_{i,j}$ respectively,\nwith $2n$ layers for each feature map size. The numbers of\nlayers are chosen such that the weight of the first layer is\nformed by convolution with a stride of 2. The network ends\nwith a global average pooling, a $10\\sqrt{2}$ -fully-connected\nlayer, and softmax. There are totally $6n+2$ stacked weighted\nlayers. The following table summarizes the architecture:\n\nso our residual models have exactly the same depth, width,\nand number of parameters as the plain counterparts.\n\n<table><tr><td>output map size</td><td>32×32</td><td>16×16</td><td>8×8</td></tr><tr><td># layers</td><td>1+2n</td><td>2n</td><td>2n</td></tr><tr><td># filters</td><td>16</td><td>32</td><td>64</td></tr></table>\n\nWhen shortcut connections are used, they are connected\nto the pairs of 3×3 layers (totally 3n shortcuts). On this\ndataset we use identity shortcuts in all cases (i.e., option A),\n\n<table><tr><td></td><td colspan=\"2\">method</td><td>error (%)</td></tr><tr><td></td><td rowspan=\"3\">Maxout [9] NIN [25] DSN [24]</td><td rowspan=\"3\"></td><td>9.38</td></tr><tr><td></td><td>8.81</td></tr><tr><td></td><td>8.22</td></tr><tr><td></td><td># layers</td><td># params</td><td></td></tr><tr><td>FitNet [34]</td><td>19</td><td>2.5M</td><td>8.39</td></tr><tr><td>Highway [41, 42]</td><td>19</td><td>2.3M</td><td>7.54 (7.72±0.16)</td></tr><tr><td>Highway [41, 42]</td><td>32</td><td>1.25M</td><td>8.80</td></tr><tr><td>ResNet</td><td>20</td><td>0.27M</td><td>8.75</td></tr><tr><td>ResNet</td><td>32</td><td>0.46M</td><td>7.51</td></tr><tr><td>ResNet</td><td>44</td><td>0.66M</td><td>7.17</td></tr><tr><td>ResNet</td><td>56</td><td>0.85M</td><td>6.97</td></tr><tr><td>ResNet</td><td>110</td><td>1.7M</td><td>6.43 (6.61±0.16)</td></tr><tr><td>ResNet</td><td>1202</td><td>19.4M</td><td>7.93</td></tr></table>\n\nTable 6. Classification error on the CIFAR-10 set. All meth-\nods are chosen as [2] . The results are averaged. $\\bar{x}$ means\nand show “ best mean±std ” as in [42] .\n\nWe use a weight decay of 0.0001 and momentum of 0.9,\nand adopt the weight initialization in [12] and BN [16] but\nwith no dropout. These models are trained with a mini-\nbatch size of 128 on two GPUs. We start with a learning\nrate of 0.1, divide it by 10 at 32x and 48x iterations, and\nterminate training at 64k iterations, which is determined on\na 256×256 visual split. During the data augmentation\noperation [24] , we randomly sample a fixed number of\na and a 32×32 crop is randomly sampled from the padded\nimage or its horizontal flip. For testing, we only evaluate\nthe single view of the original 32×32 image.\n\nWe compare $\\pi=\\{3,5,7,9\\}$ , leading to 20, 32, 44, and\n56-layer networks. Fig. 6 (left) shows the behaviour of the\nplain nets. The deep plain nets suffer from increased depth,\nand exhibit higher training error when going deeper. This\nis because the models are deeper than these plain nets and\non MNIST (see [41] ), so that on ImageNet (fig. 4 , left) and\non MNIST (see [41] ), it is hard that such an optimization\ndifficulty is a fundamental problem.\n\nFig. 6 (middle) shows the behaviors of ResNets. Also,\nsimilar to the ImageNet cases (Fig. 4 , right), our ResNets\nmanage to overcome the optimization difficulty and demon-\nstrate accuracy gains when the depth increases.\n\nWe further explore $n=18$ that leads to a 110-layer\nResNet. In this case, we find that the initial learning rate\nof 0.1 is slightly too large to start converging. $^3$ So we use\n0.01 to warm up the training until the training error is below\n80 % (about 400 iterations), and then go back to 0.1 and con-\ntinue training. The rest of the learning schedule is as done\npreviously. This 110-layer network converges well (Fig. 6 ,\nmiddle). It has fewer parameters than other deep and thin\n\nWith an initial learning rate of 0.1, it starts converging (<90% error)\nafter several epochs, but still reaches similar accuracy.\n\n776\n\n---\n\n[Figure]\n\nFigure 6. Training on CIFAR-10 . Dashed lines denote training error, and bold lines denote testing error. Left : plain networks. The error\nof plain-110 is higher than 60 % and not displayed. Middle : ResNets. Right : ResNets with 110 and 1202 layers.\n\n[Figure]\n\nFigure 7. Standard deviations (std) of layer responses on CIFAR-10.\nThe responses are the outputs of each $3 \\times 3$ layer, after BN and\nbefore nonlinearity. Top: the layers are shown in their original\norder. Bottom: the responses are ranked in descending order.\n\nnetworks such as FitNet [34] and Highway [41] (Table 6 ),\n yet is among the state-of-the-art results (6.43%, Table 6 ).\n\nAnalysis of Layer Responses. Fig. 7 shows the standard\ndeviations (std) of the layer responses. The responses are\nthe outputs of each 3 $\\times$ 3 layer, after BN and before other\nnonlinearity (ReLU/Addition). For ResNets, this analy-\nsis reveals the response strength of the residual functions.\nFig. 7 shows that ResNets have generally smaller responses\nthan their plain counterparts. These results support our ba-\nsic motivation (Sec. 3.1 ) that the residual functions might\nbe generally closer to zero than the non-residual functions.\nWe also notice that the deeper ResNet has smaller magni-\ntudes of responses, as evidenced by the comparisons among\nResNet-20, 56, and 110 in Fig. 7 . When there are more\nlayers, an individual layer of ResNets tends to modify the\nsignal less.\n\nExploring Over 1000 layers. We explore an aggressively\ndeep model of over 1000 layers. We set $n=200$ that\nleads to a 1202-layer network, which is trained as described\nabove. Our method shows no optimization difficulty , and\nour 10-layer network is able to achieve training error\n$<$ 0.1 % (Fig. 7 ). Their result is still fairly good\n(7.93 % ; Table 6 ).\n\nBut there are still open problems on such aggregately\ndescribed models that quantify the performance of neural\nnetworks. For instance, the aggregation of inputs into one\nis worse than that of our 10-layer network, although both\n\nhave similar training error. We argue that this is because of\noverfitting. The 1202-layer network may be unnecessarily\nlarge (19.4M) for this small dataset. Strong regularization\nsuch as maxout/dropout [13] is applied to obtain the\nbest results (9, 28, 24, 34) on this dataset. In this paper, we\nuse no maxout/dropout and just simply impose regulariza-\ntion via deep and thin architectures by design, without dis-\ntracting from the focus on the difficulties of optimization.\nBut combining with stronger regularization may improve\nresults, which we will study in the future.\n\n<table><tr><td>training data</td><td>07+12</td><td>07+12</td></tr><tr><td>test data</td><td>VOC 07 test</td><td>VOC 12 test</td></tr><tr><td>VGG-16</td><td>73.2</td><td>70.4</td></tr><tr><td>ResNet-101</td><td>76.4</td><td>73.8</td></tr></table>\n\nTable 7: Object detection mAP (%) on the PASCAL VOC\ntraining set against baseline Faster R-CNN. See also ap-\npendix for results details.\n\n<table><tr><td>metric</td><td>mAP@0.5 (↑)</td><td>mAP@{0.5, .95} (↑)</td></tr><tr><td>Faster R-CNN</td><td>33.7</td><td>29.1</td></tr><tr><td>R-Net-101</td><td>48.4</td><td>27.2</td></tr></table>\n\nTable 8. Object detection mAP (%) on the COCO validation set\nusing baseline Faster RCNN. See also appendix for better results.\n\n4.3. Object Detection on PASCAL and MS COCO\n\nOur method has good generalization performance on\nother recognition tasks. Table 7 and 8 show the object de-\ntection baseline results on PASCAL VOC 2007 and 2012\n[5] and COCO [26] . We adopt Faster R-CNN [32] as the de-\ntection method. Here we are interested in the improvements\nof replacing VGG-16 [40] with ResNet-101. The detection\nimplementation (see appendix) of using both models is the\nsame, so the gains can only be attributed to better networks.\nMost remarkably, on the challenging COCO dataset we ob-\ntain a 6.0 % increase in COCO's standard metric (mAP@[.5,\n.95]), which is a 28 % relative improvement. This gain is\nsolely due to the learned representations.\n\nBased on deep residual nets, we won the 1st places in\nseveral tracks in ISLRC & COCO 2015 competitions: Im-\nageNet detection, ImageNet localization, COCO detection,\nand COCO segmentation. The details are in the appendix.\n\n1\n\n---\n\nReferences\n\nY. Bengio, P. Simard and P. Frasconi . Learning long-term dependents\non past experiences. In Proc. IEEE Transactions on Information\nNetworks , 5(2):157–166, 1994.\n\n[2] C. M. Bishop, Neural networks for pattern recognition . Oxford\nUniversity press, 1995.\n\n[3] W. L. Briggs, S. F. McCormick, et al. A Multigrid Tutorial . Siam,\n2000.\n\n[6] K. Chaffatil, V. Lemovsky, A. Vedraldi, and A. Zisserman. The deviance\nof language: an evaluation of recent feature encoding methods.\nIn BMVC , 2011.\n\n[1] M. Everingham, L. Van Gool, K. E. Williams, J. Winn, and J. M. Swinski, \"Computer vision\nevaluation through borderline detection of objects (VOC) challenge\", IGCV,\npages 303–338, 2010.\n\n[6] R. Girshick. Fast R-CNN. In ICCV , 2015.\n\n19. R. Girshick, J. Donahue, T. Darrell, and J. Malik. Risk reduction for\nconvex object detection and segmentation. In\nCVPR , 2014.\n\n[8] X. Glorot and Y. Bengio. Understanding the difficulty of training\ndeep feedforward neural networks. In AISTATS , 2010.\n\n[9] I. J. Goodfellow, D. Warde-Farley, M. Mirza, A. Courville, and\nY. Bengio, Maxout networks. arXiv:1302.4389 , 2013.\n\n10 K. He and J. Sun. Convolutional neural networks at constrained time\ncost. In CVPR , 2015.\n\n#1 K. He, X. Zhang, S. Ren, and J. Sun. Spatial pyramid pooling in deep\nconvolutional networks for visual recognition. In ECCV , 2014.\n\n6. Ke, H., X. Zhang, R. Ren, and J. Sun. Delving deep into rectifier\ngains: Human-level performance on imagenet classification. In\nICCT , 2017.\n\n[3] G. E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, et al.\nDeep residual learning for convolutional neural networks, in: Proceedings of\nadaption to feature detectors, pp. 127-158(2012).\n\n[4] S. Hochreiter, Untersuchungen zu dynamischen neuronalen netzen,\nDiploma thesis , TU Munich, 1991.\n\n[15] S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural\ncomputation , 9(8):1735–1780, 1997.\n\n[16] S. Ioffi and C. Szegedy. Batch normalization: Accelerating deep\nnetwork training by reducing internal covariate shift. In ICML , 2015.\n\n[17] H. Jegou, M. Douze, and C. Schmid. Product quantization for nearest\nneighbor search. TPAMI , 33, 2011.\n\n[1] H. Jegou, F. Perronnin, M. Douze, J. Sanchez, P. Ponce, et al.\n(2018) Aggregating local image descriptors into compared codes.\nICPRAI , 2018.\n\n9. Y. Jia, E. Shelhamer, J. Dunham, K. Jarar, L. R. Cong, B. J. Bruck,\nT. Zeppenfeld, and A. Waibel. Commercial structural architectures for fast\nfast feature embbedding. arXiv:1408.5993 , 2014.\n\n[20] A. Krizhevsky. Learning multiple layers of features from tiny im-\nages. Tech Report , 2009.\n\n[1] A. Krizhevsky, I. Sutskever, and G. Hinton. Imagenet classification\nwith deep convolutional neural networks. In NIPS , 2012.\n\n22. Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Roux,\nand P. W. Hamprecht, \"Self learning by mimicking human behavior,\"\nwritten zip code recognition, Neural computation , 1989.\n\n[23] Y. LeCun, L. Bottou, G. C. Orr, and K.-R. Mller. Efficient backpropagation.\nIn Neural Networks: Tricks of the trade, pages 9–50. Springer, 1998.\n\n[24] C.-Y. Lee, S. Xie, P. Gallagher, Z. Zhang, and Z. Tu. Deeply-\nsupervised nets. arXiv:1409.5185 , 2014.\n\n[25] M. Lin, Q. Chen, and S. Yan. Network in network. arXiv:1312.4400,\n2013.\n\n2. T.-Y. Lin, M. Maire, S. Belongie, J. Hays, P. Peron, D. Ramanan,\n P. Dollár, and B. Schuller,“Microsoft COCO: Common objects in\ncontext,” in ECCV , 2014.\n\n[27] J. Long, E. Shelhamer, and T. Darrell. Fully convolutional networks\nfor semantic segmentation. In CVPR , 2015.\n\n[26] G. Montifar, R. Pascanu, K. Cho, and Y. Bengio. On the number of\nlinear regions of deep neural networks. In NIPS , 2014.\n\n[29] V. Nair and G. E. Hinton. Rectified linear units improve restricted\nboltzmann machines. In ICML , 2010.\n\n[30] F. Perronnin and C. Dance. Fisher kernels on visual vocabularies for\nimage categorization. In CVPR , 2007.\n\n[31] T. Raiko, H. Valpola, and Y. LeCun. Deep learning made easier by\nlinear transformations in perceptrons. In AISTATS , 2012.\n\n[12] S. Ren, K. He, R. Girshick, and J. Sun. Faster R-CNN: Towards\nreal-time object detection with region proposal networks. In NIPS ,\n2015.\n\n[33] B. D. Ripley. Pattern recognition and neural networks . Cambridge\nuniversity press, 1996.\n\n[34] A. Romero, N. Ballas, S. E. Kahou, A. Chassang, C. Gatta, and\nY. Bengio. Fitnets: Hints for thin deep nets. In ICLR , 2015.\n\n[9] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, M. S.\nShen, and Y. W. Li. PASCAL 2012: International Conference on\nlarge scale visual recognition, dallas, USA; 1809-0372, 2012.\n\n[46] A. M. Saxe, L. J. McClelland, and S. Ganguli. Experiments on test\nnetworks for the analysis of learning in deep linear neural networks.\narXiv:1312.6329 , 2013.\n\n[37] N. N. Schraulolph. Accelerated gradient descent by factor-centering\ndecomposition. Technical report, 1998.\n\n[38] N. E. Schraadhoff, Centering neural network gradient factors, In:\nNeural Networks: Tricks of the Trade , page 207–228. Springer,\n2016.\n\nP. Sermanet, D. Eigen, X. Zhang, M. Matta, R. Fergus, and Y. Le-\nlie. 1st International Conference on Machine Learning and Data\nMining using convolutional networks. In ICML , 2014.\n\n[40] K. Simonyan and A. Zisserman. Very deep convolutional networks\nfor large-scale image recognition. In ICLR , 2015.\n\n[14] R. K. Srivastava, K. Greff, and J. Schmidhuber. Highway networks,\narXiv:1505.00387 , 2015.\n\n[42] R. K. Srivastava, K. Greff, and J. Schmidhuber. Training very deep\nnetworks. 1507.06228 , 2015.\n\n[4] C. Szegedy, W. Li, Y. Ju, P. Sermant, S. Reed, D. Anguiano, D. Er-\nnach, and A. Rabinovich, Going deeper with convolu-\ntions, In CVPR , 2015.\n\n[44] R. Szeliski. Fast surface interpolation using hierarchical basis func-\ntions. TPAMI , 1990.\n\n[45] R. Szeliski. Locally adapted hierarchical basis preconditioning. In\nSIGGRAPH , 2006.\n\n[4] T. Vatan, T. Raiso, H. Valpola, and Y. LeCun. Pushing stochas-\ntic gradient towards second-order methods—backpropagation learn-\ning with transformations in nonlinearities. In Neural Information\nProcessing , 2013.\n\n[47] A. Vedaldi and B. Fulkerson. VLFeat: An open and portable library\nof computer vision algorithms, 2008.\n\n[48] W. Venables and B. Ripley. Modern applied statistics with s-plus,\n1999.\n\n[49] M. D. Zeiler and R. Fergus. Visualizing and understanding convolu-\ntional neural networks. In ECCV , 2014."
}